[[db.h]]

## 구현해야할 함수
• Components (in db/include/buffer.h):
	~~Buffer block (buf_descriptor_t)~~
	Hash table (hashtable_t)
	~~Buffer pool (buffer_pool_t)~~

• Functions (in db/src/buffer.cc):
	mark_buffer_dirty()
	pin_buffer()
	unpin_buffer()
	init_hashtable()
	init_buffer_pool()
	hashtable_lookup()
	hashtable_insert()
	hashtable_delete()
	get_victim_buffer()
	get_buffer()
	close_buffer_pool()
- - -
## 전체적인 Flow
### 1. **파일과 페이지의 기본 개념**
- **파일**: 데이터베이스의 데이터를 저장하는 단위. 각 테이블은 **파일로 저장**됩니다.
- **페이지**: 파일 내부의 데이터를 저장하는 기본 단위. 보통 **4KB** 또는 그 이상의 고정 크기를 가집니다.
- **디스크**: 데이터가 물리적으로 저장되는 장치. 데이터를 디스크에 기록하거나 디스크에서 읽어와 **메모리로 로드**합니다.
- **버퍼 풀**: 메모리에 존재하는 **페이지 캐시 공간**. **자주 사용되는 페이지**를 캐시해 **디스크 접근을 최소화**하고 성능을 높입니다.
---
### 🔹**순차적 과정**
#### 1) **데이터 요청**: 사용자가 데이터베이스에 데이터 조회/삽입/삭제 등 **요청**을 합니다.
- 예: 사용자가 **키 값 35에 해당하는 데이터를 조회**하려고 요청합니다.
#### 2) **버퍼 풀 탐색**:
- 데이터베이스는 **버퍼 풀에서 먼저 해당 데이터가 들어있는 페이지가 존재하는지 탐색**합니다. **버퍼 풀**은 **메모리 공간**으로, 최근에 읽거나 자주 사용하는 페이지들을 캐싱하고 있습니다.
- 예: **35라는 키 값이 저장된 페이지가 버퍼 풀에 있는지 확인**합니다.
#### 3) **버퍼 풀에 없을 경우: 디스크에서 페이지 로드**:
- **버퍼 풀에 해당 페이지가 없다면**, 데이터베이스는 해당 **페이지를 디스크에서 읽어와 버퍼 풀로 로드**합니다. 이를 **페이지 부재(Page Miss)** 라고 합니다.
- 디스크에서 페이지를 읽기 위해, 데이터베이스는 **해당 페이지의 위치(페이지 번호)** 를 찾고, **`pread()` 함수** 등을 통해 **디스크에서 해당 페이지를 메모리로 로드**합니다.
- 이때 **버퍼 풀에서 빈 공간이 없다면**, **LRU(Least Recently Used) 알고리즘** 등의 방식으로 **가장 오래 사용되지 않은 페이지를 제거**하고 새로운 페이지를 로드합니다.
- 예: **페이지 번호 8**에 해당하는 데이터를 디스크에서 읽어와 **버퍼 풀에 로드**합니다.
#### 4) **페이지 탐색 및 데이터 반환**:
- 페이지가 **버퍼 풀에 존재하면**, 해당 페이지에서 요청한 데이터를 탐색합니다.
- **B+ 트리**와 같은 데이터 구조를 이용해 페이지 내부의 **키 값을 검색**하고, **요청된 데이터**를 반환합니다.
- 예: **버퍼 풀에 로드된 페이지 8**에서 **35라는 키 값에 해당하는 데이터를 찾고 반환**합니다.
#### 5) **데이터 수정 시**:
- 데이터베이스는 **페이지의 내용을 수정**할 때, **버퍼 풀에 수정된 페이지**를 저장합니다.
- 이 페이지는 **즉시 디스크에 기록되지 않고**, 일정 시간 후 또는 다른 페이지가 버퍼 풀로 로드될 때 **디스크로 다시 기록(Write-back)** 됩니다. 이를 **페이지 플러시(Page Flush)** 라고 합니다.
- 예: **키 값 35에 대한 데이터를 수정**했다면, 해당 **페이지는 버퍼 풀에 수정된 상태로 남아 있다가 나중에 디스크로 기록**됩니다.
#### 6) **버퍼 풀에서 디스크로 페이지 쓰기**:
- 페이지가 **수정된 상태로 버퍼 풀에 있으면**, 일정 시간이 지나거나 새로운 페이지가 버퍼 풀로 로드될 때 **해당 페이지는 디스크로 기록됩니다**.
- **수정된 페이지**를 디스크에 기록할 때는, **페이지 번호에 해당하는 위치에 데이터를 씁니다**. 이를 **`pwrite()` 시스템 호출**을 통해 **해당 파일의 특정 위치에 페이지 데이터를 기록**합니다.
- 예: 수정된 **페이지 8**이 디스크의 **12KB ~ 16KB 위치에 기록**됩니다.
#### 7) **자유 페이지 관리**:
- 데이터베이스는 **자유 페이지 리스트**를 관리하여, **삭제된 페이지나 아직 사용되지 않은 페이지를 다시 할당**합니다.
- **페이지가 해제되면**, 해당 페이지는 자유 페이지 리스트에 추가되어 나중에 재사용될 수 있습니다.
- 예: 페이지가 삭제될 경우, **해당 페이지는 자유 페이지 리스트에 추가**됩니다.

- [ ] 왜 buffer pool과 disk 간에 physical independence가 유지될 수 있는건지


## 전체 최종 Flow
### 1. **사용자의 쿼리 실행**

- 사용자가 **SQL 쿼리**를 실행하면, PostgreSQL은 우선 **플래너(Planner)**와 **옵티마이저(Optimizer)**를 통해 쿼리 계획을 수립합니다. 이 계획은 **어떤 인덱스를 사용할지**, **어떻게 데이터를 읽어들일지** 등을 결정합니다.
- 만약 테이블에 **B+ 트리 인덱스**가 있다면, 쿼리 플래너는 해당 인덱스를 사용해 데이터를 찾는 계획을 수립하게 됩니다.

### 2. **B+ 트리 인덱스 탐색**

- PostgreSQL의 **B+ 트리 인덱스**는 **디스크 상의 데이터를 빠르게 찾기 위한 구조**입니다. 사용자가 찾고자 하는 데이터의 **키 값**이 주어지면, B+ 트리는 이 키 값을 기반으로 **디스크에 저장된 페이지**의 위치를 찾아냅니다.
- B+ 트리는 **범위 검색**에 매우 적합한 구조로, 각 **내부 노드**는 자식 노드로의 경로를 가리키고, **리프 노드**는 실제 데이터가 저장된 **디스크 페이지 번호**를 가지고 있습니다. B+ 트리 인덱스를 통해 PostgreSQL은 **해당 페이지 번호(pagenum_t)**를 얻습니다.

### 3. **버퍼풀 탐색 (Hash Table)**

- B+ 트리를 통해 얻은 **디스크 페이지 번호**를 가지고, PostgreSQL은 우선 **버퍼풀(Buffer Pool)**에서 해당 페이지가 **메모리에 이미 로드되어 있는지** 확인합니다. 이때 사용하는 것이 **해시 테이블(Hash Table)**입니다.
- **해시 테이블**은 페이지가 메모리에 있는지 빠르게 확인하기 위한 자료구조입니다. **페이지 번호(pagenum_t)**를 해시 키로 하여, 버퍼풀에 해당 페이지가 있는지 조회합니다. 만약 해당 페이지가 **버퍼풀에 있다면**, 해시 테이블은 해당 페이지를 가리키는 **버퍼 디스크립터**를 반환합니다.

### 4. **버퍼 디스크립터 (Buffer Descriptor)**

- **버퍼 디스크립터(buf_descriptor_t)**는 각 페이지의 **메타데이터**를 관리하는 구조체입니다. 페이지가 **참조 중인지(pinning)**, **수정되었는지(is_dirty)**, **사용 빈도(usage_count)** 등을 관리합니다.
- 만약 페이지가 이미 버퍼풀에 있으면, 해당 페이지는 메모리에서 **즉시 접근** 가능합니다. **버퍼 디스크립터**의 참조 횟수나 사용 빈도가 업데이트되며, 페이지가 **참조 중(pinned)** 상태로 유지됩니다.

### 5. **디스크 I/O 발생 (페이지가 버퍼풀에 없는 경우)**

- 만약 **해시 테이블**에서 해당 페이지가 없을 경우, PostgreSQL은 **디스크에서 직접 해당 페이지를 읽어야 합니다**. 이때 **디스크 I/O**가 발생하게 됩니다.
- 디스크에서 **해당 페이지를 읽어와 버퍼풀에 로드**합니다. 버퍼풀에 로드된 페이지는 **버퍼 디스크립터**와 연결되고, 해시 테이블에 해당 페이지가 추가됩니다.

### 6. **버퍼 교체 알고리즘 (Clock Sweep)**

- 만약 버퍼풀이 **가득 차 있다면**, PostgreSQL은 **페이지 교체 알고리즘**(예: **Clock Sweep 알고리즘**)을 사용해 **오래 사용되지 않은 페이지**를 교체합니다.
- **Clock Sweep 알고리즘**은 **사용 빈도**를 기준으로, **참조되지 않은 페이지**를 선택해 교체합니다. 선택된 페이지가 **d
- irty** 상태라면, 디스크에 다시 기록된 후 교체됩니다.

### 7. **데이터 반환**

- 최종적으로, 데이터는 **메모리에서 읽혀지거나** 디스크에서 읽혀져 **버퍼풀에 로드된 후** 사용자의 쿼리로 반환됩니다.
