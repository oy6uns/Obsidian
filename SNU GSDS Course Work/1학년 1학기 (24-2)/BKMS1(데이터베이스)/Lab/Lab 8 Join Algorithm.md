`Explain`: query plan이 어떻게 수행될 것 같은지 그 결과의 report를 예측해서 알려줌
`Explain Analyze`: query를 직접 수행한 이후에 그 결과의 report를 알려줌

# Scan
## Sequential Scan
> Heap Page들을 하나하나 보면서 조건을 만족하는 값이 있는지를 확인 

index가 sort 되어 있는 상황이면 
범위에 대한 값을 불러올 때, sequential scan이 효과적이다. 

![[스크린샷 2024-12-03 오후 6.21.56.png]]
![[스크린샷 2024-12-03 오후 6.24.11.png]]
위와 같이 where 절이 있지만, where 절에 대응되는 데이터가 거의 전체 데이터일 때 sequential scan이 실행된다. 
## Index Scan
그러나, index가 sort되어 있지 않은 상황에서 예를 들어 1000개의 데이터에서 
index < 20 인 데이터를 sequential scan하는 것은 어디에 데이터가 있을지 모르기 때문에 비효율적이다. ![[Img/Img/SNU GSDS/1학년 1학기/BKMS1(데이터베이스)/Lab/Lab 8 Join Algorithm/IMG-20250304110005-1.png]]
따라서 이경우에는 Index Scan하는 것이 더 효율적이다. 
## Index only Scan
**인덱스 자체에** 쿼리가 요청하는 **모든 정보가 포함되어 있는 경우** 인덱스만을 사용하여 **테이블을 조회하지 않고 결과를 반환**하는 방식이다. 
## Bitmap Scan
sequential scan과 index scan의 절충안

`SELECT * FROM employees WHERE age > 30 AND department = 'Sales';`
아래 두 가지 조건을 가진 쿼리가 있다고 할 때, 
- `age > 30`
- `department = 'Sales'`

**Bitmap Scan**은 각 조건에 대해 비트맵을 생성한다:
- 첫 번째 조건 `age > 30`에 대한 비트맵은 각 직원의 나이가 30보다 큰 경우 1로 표시된다. 
- 두 번째 조건 `department = 'Sales'`에 대한 비트맵은 `department`가 'Sales'인 경우 1로 표시된다. 

여러 조건을 동시에 결합하는 복잡한 쿼리에서 성능을 크게 향상시킬 수 있다. 

# Join
## Nested Loop Join
1. **외부 테이블**의 각 행을 하나씩 읽습니다.
2. **내부 테이블**을 순차적으로 읽으면서, 외부 테이블의 현재 행과 조건을 비교하여 일치하는 행을 찾습니다.
3. 일치하는 행을 찾으면 두 테이블을 결합하여 결과를 만듭니다.
4. 외부 테이블의 모든 행에 대해 이 과정을 반복합니다.
## Indexed Nested Loop Join
1. **외부 테이블**의 각 행을 하나씩 읽습니다.
2. 외부 테이블의 현재 행에서 **조건에 맞는 값을 내부 테이블의 인덱스를 사용하여 검색**합니다.
3. 일치하는 값을 찾으면 두 테이블을 결합하여 결과를 만듭니다.
4. 외부 테이블의 모든 행에 대해 이 과정을 반복합니다.
##### 장점
- 내부 테이블에 인덱스가 있으면, 빠르고 효율적인 검색이 가능하다. 
- 내부 테이블이 매우 큰 경우에도 성능을 향상시킬 수 있다. 
- 외부 테이블이 작고, 인덱스가 적절하게 설계되어 있다면 매우 효율적이다. 
## In-memory Hash join
![[Img/Img/SNU GSDS/1학년 1학기/BKMS1(데이터베이스)/Lab/Lab 8 Join Algorithm/IMG-20250304110005-2.png]]
1. 작은 테이블을 해시 테이블로 만든다. 
2. 큰 테이블을 스캔하면서 해시 테이블의 항목과 일치하면 결합한다. 
→ 테이블 크기가 메모리에 충분히 올라갈 수 있으면 In-memory Hash Join이 적합하다. 
## Hybrid Hash Join
- 작은 테이블은 메모리에 올리고, 큰 테이블은 디스크에 분할하여 저장한다. 
- 큰 테이블은 배치 단위로 나눈 뒤에, 메모리에 올릴 수 있는 배치 단위로 데이터를 반복적으로 처리한다. 
##### 디스크와 메모리를 모두 사용하여 큰 데이터 셋을 처리할 수 있지만, 
디스크 I/O가 발생하고, 디스크 I/O가 성능에 영향을 미칠 수 있다. 

## Sort-Merge Join
- 데이터를 정렬하고 병합한다. 
- 정렬된 데이터에서는 매우 효율적이지만, 정렬되지 않은 데이터나 작은 데이터를 처리할 때는 다른 방법보다 비효율적일 수 있다. 