## Transaction SQL
#### BEGIN
#### END, COMMIT
#### ROLLBACK

transaction을 안했을 때는 작업한 내용이 자동으로 flush가 됐는데, 
transaction(BEGIN)에서 작업한 내용은 flush되지 않고 지워진다. 

## Concurrency Control in PostgreSQL: MVCC
deadlock: 두개 이상의 transaction이 서로의 자원을 기다리며 무한히 멈추는 상황을 의미한다. 
서로 Resource 1, 2를 동시에 잡으면 
두 transaction 중에 하나는 포기하고, 다른 한쪽은 Apply 한다. 

### Isolation level
- Read uncommited
- Read commited
- Repeatable Read
- Serializable

## Isolation level에 따라 발생할 수 있는 문제
Isolation level에 따라서 transaction에서 발생할 수 있는 문제가 발생할수도, 안할 수도 있다!
![[스크린샷 2024-12-04 오후 6.47.16.png]]
### 1. **더티 리드(Dirty Read)**
- **정의**: **더티 리드**는 **트랜잭션 A**가 **트랜잭션 B**에서 아직 커밋되지 않은 데이터를 읽는 현상입니다.
- **문제**: 트랜잭션 B가 아직 완료되지 않은 상태에서 A가 B의 데이터를 읽었는데, B가 나중에 롤백되면 A가 읽은 데이터는 **잘못된 데이터**가 될 수 있습니다.
- **예시**:
    - 트랜잭션 A: "100원의 값을 읽는다."
    - 트랜잭션 B: "100원에서 50원으로 변경."
    - 트랜잭션 B가 **커밋되지 않고 롤백**되면, A는 잘못된 값인 50원을 읽은 것이 됩니다.
→ 트랜잭션 A가 B가 커밋되기 전까지 데이터를 읽지 않도록 해야 한다. 
### 2. **논 리피터블 리드(Non-repeatable Read)**
- **정의**: **논 리피터블 리드**는 **트랜잭션 A**가 **한 번 읽은 데이터를 다시 읽을 때** 그 데이터가 ==**다른 트랜잭션 B에 의해 변경**==된 경우입니다.
- **문제**: 트랜잭션 A가 데이터를 읽었을 때는 한 값이었지만, 같은 데이터를 다시 읽을 때 다른 값이 되어 **예상과 다른 결과**가 나올 수 있습니다.
- **예시**:
    - 트랜잭션 A: "100원의 값을 읽는다."
    - 트랜잭션 B: "100원을 200원으로 변경."
    - 트랜잭션 A가 두 번째로 같은 값을 읽었을 때 200원이 되어, **데이터가 변경된 사실을 알지 못한 채** 작업을 진행하게 됩니다.
![[스크린샷 2024-12-04 오후 6.48.37.png]]
설정을 **Read Commited**에서 **Repeatable Read**로 변경하면, 위의 그림과 같이 ==Non-repeatable Read가 허용되지 않는 것==을 확인할 수 있다. 

그러면, 변경된 버전의 레코드들은 어디에도 없는가!? 하면 그건 아니다. 
다른 버전으로 관리가 되고 있다. 

![[Img/Img/SNU GSDS/1학년 1학기/BKMS1(데이터베이스)/Lab/Lab 11 Transactions/IMG-20250304110005-1.png]]
### 3. **팬텀 리드(Phantom Read)**
- **정의**: **팬텀 리드**는 트랜잭션 A가 **같은 조건으로 쿼리를 두 번 실행**했을 때, **그 사이에 다른 트랜잭션 B**가 ==데이터를 추가하거나 삭제하여 **결과 세트가 달라지는 현상**==입니다.
- **문제**: 트랜잭션 A가 실행 중에 다른 트랜잭션 B가 데이터를 변경하면, A는 **두 번째 쿼리에서 새로운 결과 세트**를 받게 되어 일관성 없는 결과를 가져옵니다.
- **예시**:
    - 트랜잭션 A: "가격이 100원인 상품들을 모두 조회."
    - 트랜잭션 B: "가격이 100원인 상품을 하나 추가."
    - 트랜잭션 A가 **두 번째 조회**를 실행했을 때, 첫 번째 쿼리에는 없던 상품이 **새로 나타나게** 됩니다. 즉, **팬텀(유령)**처럼 새로운 데이터가 추가되거나 삭제된 것입니다.

### **4. 직렬화 이상(Serialization Anomaly)**
#### 문제의 예시:
1. **트랜잭션 A**가 **100원**을 **입금**하는 작업을 하고, **트랜잭션 B**는 **50원**을 **출금**하는 작업을 합니다.
2. 이제 **트랜잭션 C**는 **잔액**을 읽고, 그 값에 따라 작업을 진행하려고 합니다.
**문제는 여기서 발생합니다:**
- 만약 **트랜잭션 A**가 먼저 실행되어 잔액이 **100원**으로 업데이트되고, 그 후 **트랜잭션 B**가 실행되면 잔액은 **50원**이 됩니다. 트랜잭션 C는 잔액이 **50원**인 상태에서 작업을 처리합니다.
- 반대로, **트랜잭션 B**가 먼저 실행되고, 출금 작업이 먼저 이루어진 후 **트랜잭션 A**가 실행된다면, 트랜잭션 C는 **잔액이 100원**인 상태로 작업을 진행할 수 있습니다.
→ 이 경우, **트랜잭션 C**는 A와 B가 순차적으로 실행되었을 때와 **다른 결과**를 얻게 되며, 이는 시스템의 **일관성**을 깨트리는 문제가 됩니다. **직렬화 이상**이 바로 이런 상황입니다.

