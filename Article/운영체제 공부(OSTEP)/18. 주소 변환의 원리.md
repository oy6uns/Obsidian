CPU 가상화부분에서, [[제한적 직접 실행(LDE)]] 라는 기법을 집중적으로 다루었다. 

LDE의 아이디어는 간단하다. 
- 대부분의 경우 프로그램은 **하드웨어에서 직접 실행**된다. 
- **프로세스가 시스템 콜을 호출**하거나 **타이머 인터럽트가 발생**할 때 등의 **특정 순간**에는 **운영체제가 개입**하여 문제가 발생하지 않도록 한다. 
운영체제는 약간의 하드웨어 지원을 받아 ==효율적인 가상화==를 제공하기 위해 실행 프로그램에게 방해가 되지 않도록 최선을 다한다. 

메모리 가상화에서도 동시에 **효율성(efficiency)** 과 **제어(control)** 모두를 추구한다. 
프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들기 위해 **유연성(flexibility)** 측면도 고려한다.


> [!핵심 질문] 어떻게 효율적이고 유연하게 메모리를 가상화 하는가?
> - 어떻게 효율적인 **메모리 가상화(virtualization)** 를 구축할 수 있을까?
> - 프로그램이 필요로 하는 **유연성(flexibility)** 를 어떻게 제공하는가?
> - 프로그램이 접근할 수 있는 메모리의 위치에 대한 **제어(control)** 를 어떻게 유지하는가?
> - 메모리 접근을 어떻게 적절히 제한할 수 있는가?
> - 어떻게 이 모든 것을 효율적으로 할 수 있는가?

우리가 다룰 기법은 **하드웨어-기반 주소 변환** 또는 그냥 짧게 ==**주소 변환(address translation)**== 이다. 주소 변환을 통해 하드웨어는 여러 **실행 명령들이 요청한 가상 주소**를 정보가 **실제 존재하는 물리 주소**로 변환한다. 
다시 말해, **프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정**하기 위해 **하드웨어가 주소를 변환**한다. 

**메모리 가상화의 목표**: 프로그램이 자신의 전용 메모리를 소유하고 그 안에 자신의 코드와 데이터가 있다는 ==환상==을 만드는 것이다. 실제로는, 많은 프로그램이 메모리를 공유하고 있지만 말이다. 

## 18. 1 주소 변환의 원리
**프로세스의 가상 주소 공간**:
- 프로그램이 실행되면, 그 프로그램은 자신만의 메모리 주소 공간을 가진다. 이 주소 공간은 **0번지**부터 시작하는 **가상 주소**이다. 
- 프로그램에서 사용하는 변수 `x`는 **가상 주소** 공간에 위치한다. 예를 들어, 변수 `x`는 **15KB**라는 주소에 위치한다고 가정하자. 
**주소 변환**:
- 운영체제는 이 가상 주소를 실제 **물리 메모리** 주소에 배치해야 한다. 운영체제가 **물리 메모리**에서 어디에 이 프로그램을 배치할지 결정하고, 그 위치는 프로그램이 모르게 해야 한다. 
- 예를 들어, 실제 물리 메모리에서는 프로그램이 **32KB**부터 시작한다고 할 때, 가상 주소 **0번지**는 물리 주소 **32KB**로 대응되고, 프로그램이 사용하는 **15KB**는 물리 메모리의 다른 위치로 변환된다. 
![[Drawing 2024-11-30 13.34.42.excalidraw|1100]]
## 18.3 동적(하드웨어-기반) 재배치
#### 베이스와 바운드(base & bound)
이 기술은 동적 재배치(dynamic relocation)이라고도 한다. 

각 CPU마다 2개의 하드웨어 레지스터가 필요하다. 
하나는 **베이스(base)** 레지스터라고 불리고, 
다른 하나는 **바운드(bound)** 레지스터 혹은 한계(limit) 레지스터라고 불린다. 

### 베이스(base)
**프로세스에 의해 생성되는 모든 주소**가 다음과 같은 방법으로 **프로세서에 의해 변환**된다. 
`physical address = virtual address + base`

프로세스가 생성하는 메모리 참조는 **가상 주소**이다. 
1. 하드웨어는 **베이스 레지스터의 내용**을 이 **주소에 더하**여 **물리 주소를 생성**한다. 
   `128: movl 0x0(%EBX), %eax`
   프로그램 카운터(PC)는 128로 설정되고, 하드웨어는 **베이스 레지스터 값** *32KB(32768)* 에 **PC 값** *128*을 더해  *32896*의 물리 주소를 얻는다. 
2. 하드웨어는 해당 물리 주소에서 명령어를 가져온다. 
3. 프로세서는 명령어의 실행을 시작한다. 
##### → 가상 주소에서 물리 주소로의 변환이 **주소변환**이라고 부르는 바로 그 기술이다. 

### 바운드(bound)
바운드 레지스터는 보호를 위해 존재한다. 
- 프로세서는 먼저 **메모리 참조가 합법적**인가를 확인하기 위해 **가상 주소가 바운드 
  “범위” 안**에 있는지 확인한다. 
- 위의 <그림 16.1> 에선 바운드 레지스터가 16KB로 설정된다. 프로세스가 **바운드보다 큰 가상 주소 또는 음수인 가상 주소를 참조**하면 CPU는 예외를 발생시키고 프로세스는 종료된다. 
### 예외 핸들러(exception handler)
- 사용자 프로그램이 바운드를 벗어난 주소로 불법적인 메모리 접근을 시도하려는 상황에서 프로그램의 실행을 중지하고 운영체제의 **“바운드 벗어남”** **예외 핸들러(exception handler)** 가 실행되도록 조치해야 한다. 
- 사용자 프로그램이 특권이 필요한 베이스와 바운드 레지스터 값의 변경을 시도하면 CPU는 예외를 발생시키고 **“user 모드에서 특권 연산 발생” 핸들러**를 실행시켜야 한다. 


**베이스와 바운드 레지스터**는 CPU 칩 상에 존재하는 하드웨어 구조이다. 
이러한 주소 변환에 도움을 주는 프로세서의 일부를 ==**메모리 관리 장치(memory management unit, MMU)**== 라고 부르기로 하였다. 
더 정교한 메모리 관리 기법을 개발할수록 MMU에 더 많은 회로를 추가하게 될 것이다. 

## 18. 4 정리
#### 1. 프로세스 생성 시 메모리 할당
- ==프로세스가 생성==될 떄, 운영체제는 주소 공간이 저장될 **물리 메모리의 공간**을 찾아야 한다. 
- 메모리 관리: **freelist** 라는 **빈 슬롯을 관리하는 자료구조**를 통해 새로운 프로세스를 위한 메모리 공간을 찾고, 선택된 공간을 **사용 중으로 표시**한다. 
	- 빈 공간 리스트에는 비어 있는 슬롯들(예: 16KB-32KB, 48KB-64KB)만 포함된다.
#### 2. 프로세스 종료 시 메모리 회수
- ==프로세스가 종료==: 프로세스가 정상적으로 종료되거나 오류로 인해 비정상적으로 종료될 떄, 프로세스가 사용하던 메모리를 회수해야 한다. 
- ==메모리 회수==: 운영체제는 종료된 프로세스의 메모리 영역을 **freelist**에 다시 넣는다. 
#### 3. 문맥 교환(context switch) 시 베이스/바운드 레지스터 관리
- ==문맥교환==: CPU는 각 프로세스마다 고유한 베이스-바운드 레지스터 값을 가진다. 
	- 각 프로세스는 **물리 메모리 상에서 다른 위치에 로드**되므로, 실행 중인 프로세스마다 **베이스**와 **바운드** 레지스터 값이 달라야 한다. 
- ==프로세스 전환 시 작업==: 문맥 교환 시, 운영체제는 **프로세스 제어 블록(PCB)** 에 저장된 **베이스와 바운드 값**을 사용하여 CPU의 레지스터 값을 갱신한다. 
#### 4. 프로세스 주소 공간 이동
- ==주소 공간 이동==: 프로세스가 중단된 후, 실행 중이 아닌 상태에서는 프로세스의 주소 공간을 다른 위치로 이동시킬 수 있다. 
- 이동과정: 
	1. 프로세스 중단: 프로세스가 중단되면 운영체제는 현재 주소 공간을 새로운 위치로 복사한다. 
	2. 베이스 레지스터 갱신: 운영체제는 PCB에 저장된 베이스 레지스터를 새 위치에 맞게 갱신한다. 
	3. 프로세스 실행 재개: 새 베이스 레지스터 값이 복원되면, 프로세스는 새로운 위치에서 실행을 재개한다. 
- 프로세스는 ==새로운 주소 공간으로 이동한 사실을 인식하지 못하고==, 기존의 방식대로 실행을 계속한다. 
#### 5. 운영체제의 예외 처리 및 프로세스 관리
- ==운영체제의 역할==: **Exception Handler(예외 핸들러)** 또는 호출될 함수를 제공하여 예외 상황을 처리한다. 
	- 운영체제는 부팅 시 특권 명령어를 사용하여 예외 핸들러를 설치한다. 
	- 예외가 발생할 때 운영체제는 **해당 예외를 처리하기 위해 준비**되어 있어야 한다. 
- 프로세스가 **바운드 레지스터를 넘는 메모리 공간에 접근**하려 할 경우, CPU는 예외를 발생시킨다. 
- ==운영체제의 대응==: **불법 행위를 하는 프로세스를 종료**하고, 이를 통해 시스템을 보호한다. 
  → 하드웨어와 운영체제는 **협력**하여 메모리 보호 및 시스템 보안을 유지한다!!
> [!os] 운영체제와 하드웨어
> 대부분의 경우, 운영체제는 **하드웨어를 적절하게 설정하고 프로세스가 CPU 에서 직접 실행할 수 있게** 한다. 프로세스가 **잘못된 행동을 했을 때에만 운영체제가 개입**하여야 한다.

## 18. 5 요약
![[스크린샷 2024-12-02 오전 11.53.00.png]]
<그림 18.2> 에서 볼 수 있듯이, 재배치된 프로세스는 **베이스와 바운드 값**에 의해 물리 메모리에 저장된다. 
그러나, 프로세스 스택과 힙이 아주 크지 않기 때문에, 둘 사이의 공간이 단순히 낭비되고 있다. 

비록 더 많은 프로세스를 탑재할 수 있는 충분한 물리 메모리가 있더라도, **고정 크기의 슬롯**에 주소 공간을 배치해야 하기 때문에 **발생하는 낭비**를 **==내부 단편화(internal fragmentation**)==라고 한다.



