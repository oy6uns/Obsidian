**비례 배분(Proportional Share)** 스케줄러, 혹은 **공정 배분(fair share)** 이라고도 하는 유형의 스케줄러에 대해 다룬다. 

**추첨 스케줄링(lottery scheduling)** 은 **비례 배분(Proportional Share)** 스케줄러의 좋은 예로 알려져 있다. 

기본 아이디어는 매우 간단하다. 
1. 다음 실행될 프로세스를 추첨을 통해 결정한다.
2. 더 자주 수행되어야 하는 프로세스는 당첨 기회를 더 많이 준다. 
> [!핵심 질문] 어떻게 CPU를 정해진 비율로 배분할 수 있을까?

## 12. 1 추첨권 = 각 프로세스의 몫
**추첨권(티켓)** 이라는 기본적인 개념이 추첨 스케줄링의 근간을 이룬다. 
추첨 스케줄링은 이러한 목적을 (타임 슬라이스가 끝날 때마다) **확률적으로(하지만 결정적이지는 않게) 달성**한다.
![Img/Article/운영체제 공부(OSTEP)/12. 스케줄링; 비례 배분/IMG-20241202113535.png](IMG-20241202113535%202.png)
- **추첨권 양도**: 프로세스는 일시적으로 추첨권을 다른 프로세스에게 넘겨줄 수 있다. 
- **추첨권 팽창**: 일시적으로 자신이 소유한 추첨권 수를 늘이거나 줄인다. 
![Img/Article/운영체제 공부(OSTEP)/12. 스케줄링; 비례 배분/IMG-20241202113536.png](IMG-20241202113536%202.png)
추첨권의 개수(400) 중에 300이 선택되었다고 하자. 
위의 **linked list**를 순회하면서 counter 값이 winner의 값을 초과할 때 까지 반복문을 돌린다. 
300 티켓은 위의 linked list에서 프로세스 C를 가리키게 된다. 
#### 작업 시간의 공정성 분석
![Img/Article/운영체제 공부(OSTEP)/12. 스케줄링; 비례 배분/IMG-20241202113537.png](IMG-20241202113537%201.png)
##### 불공정 지표(unfairness metric) U
U는 첫 번째 작업이 종료된 시간을 두 번째 작업이 종료된 시간으로 나눈 값이다. 
완벽한 공정 스케줄러에서는 두 작업이 거의 동시에 종료되기에 U=1을 얻게 된다. 
→ 작업이 충분한 기간 동안 실행되어야 추첨 스케줄러는 원하는 결과에 가까워진다. 

## 12. 2 추첨권을 그럼 어떻게 배분해야할까?
무작위성을 이용하면 스케줄러를 단순하게 만들 수 있지만, 정확한 비율을 보장할 수 없다. 
짧은 기간만 실행되는 경우는 더 그렇다. 
##### → 이 때문에 공정 배분 스케줄러인 보폭 스케줄링(stride scheduling)을 고안하였다. 
#### 보폭 스케줄링(stride scheduling)
작업 A, B, C는 각각 100, 50, 250의 추첨권을 가지고 있다 하자. 
**임의의 큰 값**을 **추첨권 개수**로 나누면 각 작업의 `stride`를 계산할 수 있다. 

> [!stride 계산] stride 계산
> 예를 들어 10,000을 각자의 추첨권 개수로 나누면 
> 각 작업의 보폭은 100, 200, 및 40이 된다. 
> 
> → 이 값을 보폭(stride)이라고 부르며 프로세스가 실행될 때마다 **pass**라는 보폭만큼 증가시켜 얼마나 CPU를 사용하였는지를 추적한다. 

처음에는 pass의 값이 모두 0이기에 아무거나 실행된다. 
그 다음부터는 제 pass가 가장 작은 작업부터 실행된다. 

| pass_A(보폭 100) | pass_B(보폭 200) | pass_C(보폭 40) | 실행된 프로세스 |
| -------------- | -------------- | ------------- | -------- |
| 0              | 0              | 0             |          |
| 100            | 0              | 0             | A        |
| 100            | 200            | 0             | B        |
| 100            | 200            | 40            | C        |
| 100            | 200            | 80            | C        |
| 100            | 200            | 120           | C        |
| 200            | 200            | 120           | A        |
| 200            | 200            | 160           | C        |
| 200            | 200            | 200           | C        |
위의 과정을 보면 A는 2번, B는 1번, C는 5번 시행된 것을 확인할 수 있다. 
보폭 스케줄링은 각 스케줄링 주기마다 정확한 비율로 CPU를 배분한다. 

> [!NOTE] 그러면 보폭 스케줄링이 추첨 스케줄링보다 정확한데, 굳이 왜 추첨 스케줄링이 필요한가요?
> 추첨 스케줄링에서는 프로세스 상태(CPU 사용 현황, pass 값)를 유지할 필요가 없다. 
> 새 프로세스를 추가할 때, **새로운 프로세스가 가진 추첨권의 개수**, **전체 추첨권의 개수**만 갱신하고 스케줄링하면 되기에 **새 프로세스를 쉽게 추가**할 수 있다. 

## 12. 3 요약
추첨 스케줄링, 보폭 스케줄링 둘 다 개념적으로는 흥미롭지만 CPU 스케줄러로서 널리 사용되고 있지는 않다. 
1. 접근 방식이 특히 입출력과 맞물렸을 때, 제대로 동작하지 않을 때가 있다. 
	- **프로세스 A**가 I/O 작업을 기다리고 있을 때, 이 프로세스는 CPU를 사용하지 않기 때문에 **pass 값이 증가하지 않는다.**
	- 그 동안 **프로세스 B와 C**는 **CPU를 계속 사용**하면서 **pass 값이 증가**하게 된다. 
	- pass 값이 상대적으로 낮아진 I/O가 끝난 **A 프로세스**가 CPU를 독점하게 되는 문제가 발생할 수 있다. 
2. **추첨권을 얼마나 할당**할지 정하는 어려운 문제가 미해결 상태로 남아있다. 
따라서, MLFQ와 다른 유사 Linux 스케줄러가 더 널리 사용되고 있다. 


