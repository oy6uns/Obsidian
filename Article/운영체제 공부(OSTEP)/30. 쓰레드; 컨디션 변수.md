쓰레드가 계속 진행하기 전에 **어떤 조건이 참인지를 검사**해야 하는 경우가 많이 있다. 
예를 들어 부모 쓰레드가 작업을 시작하기 전에 자식 쓰레드가 작업을 끝냈는지를 검사하기를 원할 수 있다. 이런 대기문은 어떻게 구현해야 할까?
![IMG-20250107171522.png](IMG-20250107171522.png)
위의 <그림 33.2>처럼 공유 변수를 사용하는 방식은 제대로 동작하지만 부모 쓰레드가 회전을 하면서 CPU 시간을 낭비하기 때문에 비효율적이다. 따라서 이 방법 대신 쓰레드가 **특정 조건이 참이 될 때까지 잠자면서 기다리는 방법**이 더 좋다. 

## 31. 1 wait() & signal()
![IMG-20250107171523.png](IMG-20250107171523.png)
1. 부모 쓰레드가 `thr_join()`을 호출하여 `done == 1` 조건을 기다린다. 
2. 자식 쓰레드가 실행되고, `thr_exit()`을 호출하여 `done = 1`로 설정하고 신호(`pthread_cond_signal`)을 보낸다. 
3. 부모 쓰레드가 신호를 받고 `pthread_cond_wait()`에서 반환한다. 
4. 부모 쓰레드가 실행을 재개하고 종료한다. 

> [!IMPORTANT] Signal & Lock
> **시그널을 보낼 때, 대기할 때는 락을 무조건** 걸어야 한다. 
> done 값이 1이 되기 전에 부모 쓰레드가 다시 실행되면 잠든 부모 쓰레드는 영원히 잠들어버리는 **Race Condition**이 발생하기 때문이다!

## 31. 2 공유 버퍼의 사용
버퍼는 데이터를 저장하는 공간이라 하자. 
생산자 쓰레드는 데이터를 만들어 버퍼에 넣고, 소비자 쓰레드는 버퍼에서 데이터를 꺼내어 사용한다. 
생산자와 소비자가 공유 버퍼에 접근할 때 **동기화 메커니즘**(뮤텍스, 세마포어, 컨디션 변수 등)을 통해 하나의 쓰레드만 하나의 버퍼에 접근 가능하도록 보장해야 한다. 
![IMG-20250107171523-1.png](IMG-20250107171523-1.png)
![IMG-20250107171523-2.png](IMG-20250107171523-2.png)
소비자와 생산자가 한 명일 경우에는 `lock()`만 잘 걸어주면, 생산자가 넣은 데이터를 소비자가 모두 볼 수 있기 때문에 문제가 생기지 않지만, 만약 **소비자가 여러명이 될 경우 문제가 발생**한다. 
1. 한 소비자 $T_{c1}$ 가 신호를 받아 실행 대기 상태로 전환
2. 다른 소비자 $T_{c2}$가 실행되어 버퍼의 데이터를 소비
3. $T_{c1}$이 실행되었을 때 버퍼가 이미 비어있는 상태가 되어, 잘못된 동작이 발생
다른 소비자가 버퍼의 데이터를 중간에 채가지 못하게, `if`문 대신에 `while`문으로 변경해준다. 이러면 기존 소비자가 버퍼의 데이터를 계속 보게끔 만들기에, 데이터의 **race condition**을 방지할 수 있다. ![IMG-20250107171524.png](IMG-20250107171524.png)
두 개의 **컨디션 변수(empty, fill)** 로 명확하게 신호를 전달하여 **race condition**을 방지한다. 
그러나, 단일 버퍼에서는 **생산자가 소비자를 기다리고, 소비자가 생산자를 기다리는 비효율**이 발생한다. 다중 버퍼로 변경하면 **생산자와 소비자가 서로 독립적으로 작업할 수 있어 병렬성이 증가**하게 된다. 
## 31. 3 다중 버퍼로의 변경
![IMG-20250107171524-1.png](IMG-20250107171524-1.png)![IMG-20250107171524-2.png](IMG-20250107171524-2.png)
다중버퍼를 도입함으로써 아래의 장점을 얻을 수 있다. 
1. 생산자와 소비자의 대기 시간 감소
	- 단일버퍼는 생산자가 데이터를 넣고 소비자가 데이터를 꺼내기 전까지 생산자는 대기해야 한다. 그러나, 다중 버퍼는 **동시에 여러 데이터를 병렬적으로 연속으로 넣고 뺄 수** 있기에 **대기 시간이 줄어든다**. 
2. 문맥교환 감소
	- 단일 버퍼에서는 생산자와 소비자가 자주 대기 상태에 들어가 문맥 교환이 잦지만, 다중 버퍼에서는 대기 없이 작업을 이어갈 수 있어 문맥 교환 횟수가 줄어든다. 

결과적으로, 
**락(Lock)** 은 ==공유 자원(데이터, 메모리 등)==에 여러 쓰레드가 ==동시에 접근하는 것을 막고==,
**컨디션 변수(Condition Variable)** 은 ==데이터가 준비되었을 때 대기 중인 쓰레드에 신호를 보냄==으로써 원하는 방향으로 프로그램이 동작할 수 있게 해준다. 

**컨디션 변수**는 락 이상으로 ==중요한 동기화 기법==으로 프로그램 상태가 기대한 것과 다를 경우 **쓰레드가 대기하도록 하여 동기화 문제를 해결**할 수 있다. 

