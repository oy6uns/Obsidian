일반적으로 프로세스는 **실행 중인 프로그램**으로 정의한다. 

프로그램은 디스크 상에 존재하며 **실행을 위한 명령어**와 **정적 데이터**의 **묶음**이다. 

> [! ] CPU가 여러 개 존재한다는 환상을 어떻게 제공하는가
> 적은 개수의 CPU밖에 없더라도, 운영체제는 어떻게 거의 무한개에 가까운 CPU가 있는 듯한 환상을 만들 수 있을까?

운영체제는 CPU를 `가상화`하여 이러한 환상을 만들어 낸다. 

하나의 **프로세스를 실행**하고, **얼마 후 중단**시키고 **다른 프로세스를 실행**하는 **작업을 반복**하는 `time sharing` or `context switch(문맥 교환)` 기법을 통해 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 한다. 
물론, CPU를 공유하기 때문에 각 프로세스의 성능은 낮아진다. 

**운영체제의 지능**은 정책(policy)의 형태로 표현된다. 
예를 들어, 실행가능한 여러 프로그램들이 있을 때, 운영체제의 `스케줄링 정책(scheduling policy)`이 **어느 프로그램을 먼저 실행시킬지에 대한 결정**을 내린다. 
→ 이러한 결정을 내리기 위하여 스케줄링 정책은 과거 정보
1. 직전 1분 동안 어떤 프로그램이 자주 실행되었는가?
2. 어떤 유형의 프로그램이 실행되었나?
3. 시스템이 대화 성능 혹은 처리량을 높이려 하는지
등을 이용한다. 

## 7. 1 프로세스의 개념
- 실행 중인 프로그램
### 프로세스 API
- 생성: 운영체제는 새로운 프로세스를 생성할 수 있는 방법 제공
- 제거: 운영체제는 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 한다. 필요없는 프로세스를 중단시키는 API는 매우 유용하다. 
- 대기: 때론 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에 여러 종류의 대기 인터페이스가 제공된다. 
- 상태(Status): 프로세스 상태 정보를 얻어내는 인터페이스도 제공된다. 

### 프로세스의 생성
1. **프로그램 코드와 정적 데이터**(static data, 초기값을 가지는 변수)를 메모리, **프로세스의 주소 공간에 탑재**
   → 디스크의 해당 바이트를 읽어서 메모리의 어딘가에 저장
2. 일정량의 메모리가 프로그램의 실행시간 스택(run-time stack) 용도로 할당되어야 한다. 
3. heap은 동적으로 할당된 데이터를 저장하기 위해 사용된다. 
   `malloc()`을 호출하여 필요한 공간을 요청하고, 
   `free()`를 호출하여 사용했던 공간을 반환하여 다른 프로그램이 사용할 수 있도록 한다. 

### 프로세스 상태
- 실행: 프로세스는 프로세서에서 명령어를 실행 중이다. 
- 준비: 프로세스는 실행할 준비가 되어 있지만, 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중이다. 
- 대기: 프로세스가 **다른 사건**을 기다리는 동안 프로세스의 수행을 중단 시킨다. 
  흔한 예: 프로세스가 디스크에 대한 입출력 요청을 하였을 때 입출력이 완료될 때까지 대기 상태가 된다. 
![Img/Article/운영체제 공부(OSTEP)/7. 프로세스란/IMG-20241202113535.png](IMG-20241202113535%203.png)
**프로세스 리스트**: 프로세스의 관리를 위한 정보를 저장하는 자료 구조를 프로세스 제어 블럭 **(Process Control Block, PCB)** 라고 부른다. 

**레지스터 문맥(register context)**: 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장한다. 이 레지스터 값들을 복원하여 운영체제는 프로세스 실행을 재개한다. 
→ **문맥 교환(context switch)** 라고도 한다. 

# 7. 2 프로세스 API 
![IMG-20241202113535-1.png](IMG-20241202113535-1.png)
# 7. 3 제한적 직접 실행 원리
-  하드웨어는 2가지 실행 모드를 제공하여 os를 돕는다. 
	- user mode
	- kernel mode
- 사용자 프로세스가 디스크 읽기와 같은 특권 명령어를 실행해야할 때는?
	- `시스템 콜`을 제공
- trap: 커널 안으로 분기하는 동시에 특권 수준을 커널 모드로 상향 조정
  → os는 모든 명령어를 실행할 수 있고, 프로세스가 요청한 작업을 처리 가능
- return-from-trap 명령어: 특권 수준을 user mode로 하향 조정하고, 호출한 사용자 프로그램을 return 
- trap, return-from-trap을 위해서 레지스터들을 저장해야 한다. 
	- x86에서는 프로그램 카운터(pc), flag와 다른 몇 개의 register를 각 프로세스의 kernel stack에 저장한다. 이후 return-from-trap 명령어가 이 값들을 stack에서 pop하여 user mode 프로그램의 실행을 다시 시작한다. 
### 1. 커널(Kernel)
- **커널**은 운영체제의 핵심 부분입니다. 컴퓨터의 하드웨어와 소프트웨어가 효율적이고 안전하게 동작할 수 있도록 모든 시스템 자원을 관리합니다.
- 커널은 하드웨어와 **user programs (사용자 프로그램)** 사이에서 중요한 역할을 하며, **kernel mode**에서 실행됩니다.
- 커널은 시스템의 안정성과 보안을 책임지기 때문에, **커널 모드**에서는 하드웨어와 직접 상호작용할 수 있는 권한이 있습니다.
### 2. 커널 스택(Kernel Stack)
- **커널 스택**은 커널 모드에서 실행 중인 함수나 프로세스의 데이터를 저장하는 메모리 공간입니다.
- 프로그램이 실행되면, 그 실행 과정에서 필요한 변수와 상태 정보를 저장하는 스택 영역이 필요합니다.
- 커널 스택은 **kernel mode**에서만 사용되며, 사용자 모드의 프로그램과는 분리되어 있습니다. 이렇게 분리된 스택을 통해 시스템이 안정적으로 운영될 수 있습니다.
### 3. 트랩(Trap)
- **트랩**은 프로그램이 **usermode**에서 **kernel mode**로 전환되는 과정입니다.
- 예를 들어, 사용자 프로그램이 하드웨어 자원을 사용하려면 커널의 도움을 받아야 하므로, 시스템 호출을 통해 **트랩**이 발생합니다.
- 트랩은 주로 **예외 상황**(예: 잘못된 메모리 접근, 나누기 0)이나 **시스템 호출**(예: 파일 열기, 네트워크 요청)로 인해 발생하며, 이때 커널이 개입하여 필요한 작업을 처리합니다.
### 4. 트랩 테이블(Trap Table)
- **트랩 테이블**은 트랩이 발생했을 때, 커널이 적절한 처리 과정을 찾을 수 있도록 돕는 데이터 구조입니다.
- 트랩 테이블은 **트랩 코드**를 기반으로 실행할 함수를 결정하는 역할을 합니다. 즉, 트랩이 발생하면 트랩 테이블에서 해당 트랩에 대응하는 함수의 주소를 찾아서 그 함수를 실행합니다.
- 예를 들어, 파일을 읽으려는 요청이 트랩을 통해 커널로 전달되면, 트랩 테이블은 파일 입출력을 담당하는 함수로 그 요청을 전달합니다.
![Img/Article/운영체제 공부(OSTEP)/7. 프로세스란/IMG-20241202113537.png](IMG-20241202113537%203.png)
## 프로세스 간 전환
운영체제는 실행 중인 프로세스를 계속 실행할 것인지, 멈추고 다른 프로세스를 실행할 것인지를 결정해야 한다. 
그러나 CPU에서 프로세스가 실행(`return-from-trap`) 중 → 운영체제는 실행 중이 아님
그렇다면 운영체제가 실행되고 있지 않다면 **어떻게 CPU를 다시 획득하여** 프로세스 간 전환을 어떻게 할 수 있을까?

- 협조 방식: 시스템 콜 기다리기
- 비협조 방식: **타이머 인터럽트(timer interrupt)** 를 이용한다. 
  인터럽트가 발생하면 현재 수행 중인 프로세스는 중단되고 미리 구성된 운영 체제의 **인터럽트 핸들러(interrupt handler)** 가 실행된다. 
  이 시점에 운영체제는 CPU 제어권을 다시 얻게 되고 자신이 원하는 일을 할 수 있다. 
	ex. 현재의 프로세스를 중단하고 다른 프로세스를 실행시키는 작업 등

인터럽트 발생 시 **하드웨어**는 실행 중이던 프로그램의 상태를 저장하여 나중에 운영체제에서 `return-from-trap` 발생 시에 해당 명렁어가 프로그램을 다시 시작할 수 있도록 해야한다. 

## 어떻게 운영체제는 프로세스를 제어할까?
시스템 콜을 통하여 **협조적**으로 하던, timer interrupt를 통해 **반강제적**으로 하던, 
운영체제가 제어권을 다시 획득하면 중요한 결정을 내려야 한다. 

**현재 실행 중인 프로세스를 계속 실행할 것인지** || **다른 프로세스로 전환할 것인지**
이 결정은 운영체제의 `스케줄러(scheduler)` 라는 부분에 의해 내려진다. 

다른 프로세스로 전환하기로 결정되면 운영체제는 `문맥 교환(context switch)`라 알려진 코드를 실행한다. 문맥 교환은 개념적으로는 간단하다. 
1. 현재 실행 중인 프로세스의 상태인 **레지스터, Process Counter, 커널 스택 포인터 등이 [PCB, 프로세스 제어 블록](../OS%20개념별%20정리/PCB,%20프로세스%20제어%20블록.md)라는 데이터 구조체에 담겨 커널 메모리 영역에 저장된다. 
2. 곧 실행될 프로세스의 커널 스택으로부터 **레지스터**를 복원
위 과정을 통해 현재 실행중이던 프로세스로 리턴하는 것이 아니라 다른 프로세스로 리턴하여 실행을 다시 시작할 수 있다. 
![IMG-20241202113537-1.png](IMG-20241202113537-1.png)
![Img/Article/운영체제 공부(OSTEP)/7. 프로세스란/IMG-20241202113538.png](IMG-20241202113538%202.png)
1. 첫번째 타이머 인터럽트
   **실행 중인 프로세스의 사용자 레지스터**가 **하드웨어**(타이머 인터럽트)에 의해 **커널 메모리에 저장**된다. 
   **저장 위치**는 **해당 프로세스의 커널 스택**이다. 커널 모드로 전환되면서 실행 중인 프로세스의 레지스터 값은 해당 프로세스의 커널 스택에 저장된다. 
2. 두번째 타이머 인터럽트
   **운영체제**가 **A에서 B로 전환하기로 결정**했을 때, 
   프로세스 A의 레지스터 정보는 **A의 커널 스택**에 저장되고, 프로세스 B로 전환되면 프로세스 B의 **PCB**에서 레지스터 정보를 복원한다. 이 복원된 값으로 **프로세스 B**가 실행된다.
   B의 커널 메모리에 적힌 레지스터 정보는 운영체제에 의하여 해당 프로세스의 PCB에 저장된다. 이는 운영체제가 A가 아닌 B로부터 커널로 트랩된 것처럼 만든다. 
운영체제는 **타이머 인터럽트**로부터 발생한 상태에서 `trap()`이라는 **시스템 호출**을 처리한다. `trap()`은 인터럽트가 발생한 지점을 처리하는 함수이고, 그 후에 **`switch()` 함수**를 통해 프로세스 스케줄링을 처리하게 된다. 
즉, 운영체제는 ==어떤 프로세스가 실행 중이었는지에 대한 직접적인 정보는 모르고==, **현재 실행 중인 프로세스를 저장하고** 새로 실행할 프로세스를 **복원**하는 방식으로 동작한다. 



