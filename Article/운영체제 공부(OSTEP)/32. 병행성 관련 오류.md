## 32. 1 교착 상태(deadlock) 오류
![[IMG-20250109173211.png]]
이 코드에서는 교착 상태가 발생할 수 있다. 발생하는 경우를 살펴보자. 
1. **쓰레드 1**이 **락 L1**을 획득하고 난 후에 문맥 교환이 발생하여 **쓰레드 2가 실행**한다.
2. 그때, **쓰레드 2** 가 **락 L2**를 획득하고 **락 L1**을 획득하려고 시도한다. 
그러면 교착 상태가 발생한다. 각 쓰레드가 상대방이 소유하고 있는 락을 대기하고 있기 때문에 누구도 실행할 수 없게 된다. 그래프에서 ==**사이클(cycle)의 존재**==는 교착 상태 발생 가능성을 의미한다.
![[IMG-20250109173438.png]]
교착 상태가 발생하기 위해서는 네 가지 조건이 충족되어야 한다. 
- **상호 배제(Mutual Exclusion)**: 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장한다(예, 쓰레드가 락을 획득함).
- **점유 및 대기(Hold-and-wait)**: 쓰레드가 자신에게 할당된 자원(예: 이미 획득한 락)을 점유한 채로 다른 자원(예: 획득하고자 하는 락)을 대기한다.
- **비 선점(No preemption)**: 자원(락)을 점유하고 있는 쓰레드로부터 ==자원을 강제적 으로 빼앗을 수 없다==.
- **환형 대기(Circular wait)**: 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원(락)을 갖고 있는 ==쓰레드들의 순환 고리==가 있다.

## 32. 2 교착 상태의 예방
#### 1. 순환 대기(Circular wait)
아마 가장 실용적인 deadlock 예방 기법은 순환 대기가 절대 발생하지 않도록 락 코드를 작성하는 것이다. 락 획득을 하는 **전체 순서(total ordering)** 을 정하는 것이다. 좀 더 복잡한 시스템의 경우, 두 개 이상의 락이 존재할 것이고 전체 락의 요청 순서를 정의하는 것이 어려울 수 있따. 이를 피하기 위해 **부분 순서(partial ordering)** 를 제공하는 것이 락 획득 구조를 만드는 데 유용할 것이다. 
##### 예시 1
- 프로세스 A는 항상 L1 → L2 순서로 락을 획득.
- 프로세스 B도 항상 L1 → L2 순서로 락을 획득.
- 이렇게 하면 락 획득 순서가 일관되므로 **순환 대기 조건이 발생하지 않는다.**
##### 예시 2
주소를 기반으로 락을 획득하는 순서를 정하는 방법도 있다. 
- 작은 주소의 락을 먼저, 큰 주소의 락을 나중에 획득하도록 강제하면 순서가 꼬이지 않는다. 
#### 2. 점유 및 대기(Hold-and-Wait)
**모든 락을 한 번에 획득하도록 강제**하여, 자원을 점유한 상태에서 추가 요청을 하지 않도록 만든다. ![[IMG-20250109174353.png]]
###### deadlock을 예방하지만, 
1. 모든 락을 미리 알아야 하고
2. 자원이 실제로 필요하지 않을 때도 미리 점유하므로, 병렬 처리 성능을 저하시킨다. 
#### 3. 비선점(No Preemption) 예방
프로세스가 자원을 요청했을 때, 필요한 자원을 획득하지 못하면 **이미 점유 중인 자원을 해제하고 재시도**하도록 강제한다. 
![[IMG-20250109174547.png]]
- `trylock`을 사용:
	- 락을 즉시 시도하고, 실패하면 -1을 반환.
	- L2 락을 획득하지 못하면 L1 락을 해제하고 다시 시도.
###### deadlock을 예방하지만, 
1. 두 프로세스가 **서로 자원을 반복적으로 점유/해제**하면서 진전이 없는 상태에 빠질 수 있음.
	- **해결 방법**: 재시도 횟수를 제한하거나, 대기 시간을 무작위로 조정하여 충돌 가능성을 줄임.
2. 점유한 자원을 해제하고 재시도하는 로직이 복잡할 수 있음.
#### 4. 상호 배제(Mutual Exclusion)
상호 배제(Mutual Exclusion) 없이, 즉 락(lock)을 사용하지 않고 교착 상태를 예방하는 **대기 없는(wait-free) CAS** 자료 구조를 만든다. 
##### CAS(Compare-And-Swap)란?
CAS는 **한 번에(원자적으로)** 값을 비교하고, 필요하면 값을 바꾸는 작업을 하는 도구이다. 
- **비교(Compare)**: 메모리에 있는 값이 내가 예상한 값과 같은지 확인.
- **교환(Swap)**: 같으면 새로운 값으로 바꿈. 다르면 아무것도 하지 않음.
예를 들어:
1. 내가 메모리에 있는 값이 `100`이라고 예상
2. 바꾸고 싶은 새 값은 `200`
3. CAS가 확인:
    - 메모리에 실제 값이 `100`이 맞으면, 그 값을 `200`으로 바꿈.
    - 값이 이미 다른 스레드에 의해 `150`으로 바뀌었으면 아무것도 안 하고 실패를 알림. 
##### CAS의 장점
- 여러 스레드가 동시에 같은 데이터를 바꾸려고 할 때, **락을 걸지 않고 안전하게 값을 바꿀 수 있음.**
- 락 없이도 동기화를 할 수 있어서 빠르고 효율적임.
###### 단점
- 경쟁이 심한 환경에서는 CAS가 계속 실패하여 작업이 지연될 수 있음.
- 이 경우 **Livelock(무한 반복)** 상태에 빠질 가능성 존재.

## 32. 3 교착 상태의 회피
#### 1. 스케줄링으로 교착 상태 회피하기
![[IMG-20250109175334.png]]
어떤 시나리오에서는 교착 상태를 예방하는 대신 회피하는 것이 더 유용할 때가 있다. 위의 예처럼 쓰레드 네 개가 프로세서 두 개에서 스케줄링된다고 해 보자. T1과 T2가 동시에 실행만 하지 않는다면 교착 상태가 절대로 발생하지 않도록 할 수 있다. 그와 같이 스케줄링된 예는 다음과 같다.![[IMG-20250109175416.png]]
![[IMG-20250109175429.png]]
두번째 시나리오에선, T1, T2, T3가 모두 동시에 실행되면 안된다. 교착 상태가 절대로 발생하지 않도록 하는 가능한 스케줄링은 다음과 같다.
![[IMG-20250109175507.png]]
위의 스케줄링 예처럼 잘못 스케줄링 시에는 어쩔 수 없는 성능 하락을 수반한다. 때문에 스케줄링으로 교착 상태를 회피하는 것은 **보편적으로 사용되는 방법은 아니다.**
#### 2. 발견 및 복구(Recovery)
교착 상태 발생을 허용하고, 교착 상태를 발견하면 복구토록 하는 방법 이다. 예를 들어 운영체제가 일 년에 한 번 멈춘다고 했을 때 재부팅을 하고 다시 작업을 처리하는 식이다. 교착 상태가 아주 가끔 발생한다면 이런 방법도 꽤 유용하다.
