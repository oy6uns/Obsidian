메모리 관리 시스템의 근본적인 측면을 논의한다. 
- **프로세스 힙의 페이지를 관리**하는 `malloc` 라이브러리일 수도 있고, 
- **프로세스 주소 공간의 일부분을 관리**하는 `운영체제 자체`일 수도 있다. 

전 단원에서 배웠듯, 관리하고 있는 공간이 **고정 크기의 단위**로 나누어져 있는 경우는 매우 쉽다. 
문제는 관리하는 공간이 크기가 들쭉날쭉한 **가변 공간들의 집합인 경우**이다. 이 경우는
- `malloc()`과 `free()`에서 처럼 사용자-수준 메모리-할당 라이브러리에서, 
- `segmentation`으로 물리 메모리를 관리하는 `운영체제`에서 발생한다. 
어느 경우에도 **[외부 단편화](obsidian://open?vault=Obsidian%20Vault&file=Article%2F%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B3%B5%EB%B6%80(OSTEP)%2F19.%20%EC%83%88%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98)** 가 존재한다. 
#### 외부 단편화
빈 공간은 ==**다양한 크기의 작은 조각으로 분할**==되어 결국 단편화된다. 
→ **빈 공간들의 전체 크기**가 **요청된 것보다 크더라도**, **==하나의 연속된 영역**이 존재하지 않으면== 요청은 실패할 수 있다. 
![IMG-20241221144052.png](IMG-20241221144052.png)
위 경우 빈 공간의 전체 크기는 20바이트이다. 불행히도, 10바이트 짜리 두 조각으로 나누어져 있다. 그 결과, 20바이트의 빈 공간이 있지만 15바이트의 요청은 실패한다. 이것이 이 장에서 해결하고자 하는 문제이다.


> [!빈공간 관리] 빈 공간을 어떻게 관리해야하는가!
> - 가변 크기의 요구를 충족시켜야 할 때, **빈 공간을 어떻게 관리**되어야 할까?
> - **단편화를 최소화하기 위한 전략**을 세워보자!
> - 각 **전략들의 시간과 공간의 오버헤드**도 비교해보자

## 20. 1 저수준 기법들
우선 몇 가지 가정을 하고 가자!
- **내부 단편화 문제**도 있을 수 있지만, **외부 단편화 방지에 특히 중점**을 두고 가자!
- **클라이언트에게 할당된 메모리**는 **다른 위치로 재배치**될 수 없다고 가정하자!
  → `malloc()`을 호출하여 힙의 일부 영역에 대한 포인터를 받으면 `free()`를 통해 반환되기 전까지 다른 위치로 옮겨질 수 없다. (**압축을 사용하지 않는다**고 가정하자!!)

세부 정책에 대해 자세히 설명하기 전에 먼저 일반적으로 사용되는 기법에 대해 논의하자. 
### 분할과 병합
#### 분할(splitting)
30바이트의 힙이 있다고 가정하자. 
![IMG-20241222181837.png](IMG-20241222181837.png)
이 힙의 **Free List**에는 2개의 원소가 있다. 
- 하나는 첫 번째 10바이트의 빈 세그먼트(**0~9 바이트**)
- 다른 하나는 나머지 빈 세그먼트(**20~29 바이트**)
![IMG-20241222182201.png](IMG-20241222182201.png)
10바이트를 초과하는 모든 요청은 실패하여 `NULL`을 반환할 것이다. 
요청한 크기에 해당하는 메모리 청크가 없기 때문이다. 

메모리를 1바이트만 요청했다고 가정하자. 그리고 **할당기는 리스트의 두 번째 원소를 사용**하여 요청을 충족시키기로 결정했다고 가정하자. 
`malloc()`은 20을 반환하고 최종 Free List는 아래와 같이 될 것이다. 
![IMG-20241222182430.png](IMG-20241222182430.png)
기본적인 리스트의 모습은 바뀌지 않았다. 유일한 변경 사항은 
- 빈 공간이 이제 20이 아니라 21에서 시작한다는 것과
- 빈 공간의 길이가 이제 9라는 것이다. 
#### 병합(coalescing)
응용 프로그램이 `free(10)`을 호출하여 힙의 중간에 존재하는 공간을 반환하게 되면 **Free List**는 아래와 같은 형태를 띠게 된다. 
![IMG-20241222183306.png](IMG-20241222183306.png)
사용자가 20바이트를 요청하는 경우 단순한 리스트 탐색은 빈 청크를 발견하지 못하고 실패를 반환한다. 할당기가 이 문제를 방지하기 위해서는 **메모리 청크가 반환되리 때 빈 공간들을 병합**하면 된다. 
1. 메모리 청크를 반환한 청크의 주소와 바로 **인접한 빈 청크의 주소를 살펴본다**. 
2. 새로 해제된 빈 공간이 어느 한쪽의 청크와 바로 인접해 있다면 **그들을 하나의 더 큰 빈 청크로 병합**한다. ![IMG-20241222183730.png](IMG-20241222183730.png)
### 할당된 공간의 크기 파악
`free(void *ptr)`는 크기를 매개변수로 받지 않는다. 전달받은 포인터를 기준으로 메모리 공간의 크기를 알아내고, 해당 공간을 해제한다. 근데, ==해제시킬 메모리 공간의 크기는 어떻게 알아낼까==??

`malloc`함수는 사용자가 요청한 메모리 외에도 추가 정보를 저장하기 위해 메모리 앞부분에 ==**“헤더”**== 를 추가로 사용한다. 
- **메모리 크기(size)**: 사용자가 요청한 크기
- **매직 넘버(magic_num)**: 올바른 해제 여부를 확인하기 위해(무결성 검사) 사용되는 값
![900](../../Excalidraw/Drawing%202024-12-22%2019.06.28.excalidraw.md)
사용자는 이 헤더를 직접 접근할 필요가 없으며, `malloc`과 `free`가 내부적으로 관리한다. 
#### 예시
1. 사용자가 20바이트를 요청한다: `{cpp} void *ptr = malloc(20)` 
	- 할당된 메모리 구조: `{cpp} <그림 20.2>`
2. 사용자가 할당한 메모리를 해제한다: `{cpp}free(ptr)` 
	- `free`함수는 `ptr`을 기준으로 헤더를 찾아 매직 넘버를 확인하고, 메모리를 반환한다. 
	- **헤더 포인터** 접근
	  `{cpp}header_t *hptr = (void *)ptr - sizeof(header_t);`
	- **무결성** 검사
	  `{cpp}assert(hptr->magic == 123423);`


> [!note] 공간 할당!
> 즉, 우리가 평상시에 사용하는 `{cpp}malloc()`함수가 할당하는 빈 영역의 크기는 
> **(사용자가 할당한 영역의 크기)** 에 **(헤더 크기)** 를 더한 만큼인 것이다!!!

### Free List
그럼 Free List를 빈 공간에 어떻게 구현할 수 있을까?
#### 힙의 공간 > 할당할 메모리의 공간
![900](../../Excalidraw/Drawing%202024-12-22%2020.06.25.excalidraw.md)
`mmap 시스템콜`호출로 heap이 초기화되고, **4KB**의 청크가 할당된다. 
- 100 바이트씩 총 3개의 공간이 할당되고
- 차례대로 해제되는 상황이다. 
모든 메모리가 비어있긴 하지만, 각 청크들이 전부 조각나 있다. 
이 경우에는 ==**Free List**를 순회하면서 **인접한 청크를 병합**==시키면 해결된다!
#### 힙의 확장: 힙의 공간 < 할당할 메모리의 공간
→ 힙 공간이 부족한 경우에는 어떻게 할까?
Ans) 쉬운 방법은 단순히 **실패를 반환**하는 것이다!

그러나, 대부분의 할당기는 적은 힙으로 시작하여 **운영체제로부터 더 많은 메모리를 요청**한다. 
- 할당기는 힙을 확장하기 위해 **특정 시스템 콜을 호출**한다. (대부분의 UNIX 시스템에서는 `sbrk`를 호출한다.)
- 확장된 영역에서 **새로운 청크를 할당**하고, **새로운 힙의 마지막 주소를 반환**한다. 
## 20. 2 다양한 빈 공간 탐색 기법
빈 공간 할당을 위한 여러 기본 전략들에 대해 살펴보자. 
#### 최적 적합(Best Fit)
1. 빈 공간 리스트를 검색하여 요청한 크기와 같거나 더 큰 빈 메모리 청크를 찾는다. 
2. 후보자 그룹 중에서 가장 작은 크기의 ==**최적 청크**==를 반환한다. 
: 빈 블럭을 찾기 위해 항상 전체를 검색해야 하기 때문에 엄청난 성능 저하를 초래한다. 
#### 최악 적합(Worst Fit)
1. ==**가장 큰 빈 정크**==를 찾아 요청된 크기 만큼만 반환하고 남는 부분은 Free List에 계속 유지한다. 
: 이 또한 빈 공간 전체를 탐색해야 한다. 
#### 최초 적합(First Fit)
1. 요청보다 큰 첫 번째 블럭을 찾아서 요청만큼 반환한다. 
: 속도가 빠르지만, 때때로 리스트의 시작에 크기가 작은 객체가 많이 생길 수 있다. 
#### 다음 적합(Next Fit)
1. 항상 리스트의 처음부터 탐색하는 대신, **마지막으로 찾았던 원소를 가리키는 추가의 포인터를 유지**한다. 

### 실제 예시
![스크린샷 2024-12-22 오후 9.00.54.png](../../Img/스크린샷%202024-12-22%20오후%209.00.54.png)
크기가 각각 10, 30, 및 20인 세 개의 원소를 가진 Free List가 있다고 생각해보자! 
(헤더와 다른 세부사항은 무시하고 생각하자!)

1. 최적 적합![스크린샷 2024-12-22 오후 9.02.19.png](../../Img/스크린샷%202024-12-22%20오후%209.02.19.png)전체 리스트를 검색하여 **조건을 만족시키는 청크 중 가장 작은 20**을 선택!
2. 최악 적합![스크린샷 2024-12-22 오후 9.04.35.png](../../Img/스크린샷%202024-12-22%20오후%209.04.35.png)
   전체 리스트를 탐색하여 **조건을 만족시키는 청크 중 가장 큰 30**을 선택!
   
## 20. 3 다른 접근법
#### 개별 리스트 (Segregated List)
- 메모리를 효율적으로 관리하기 위해 **크기별로 분리된 리스트**를 유지하는 방법
- **요청된 크기에 딱 맞는 청크를 유지**하기 때문에 불필요한 검색 과정이 없다. 
: 파일 시스템이나 램 캐시처럼 **==크기가 일정한 데이터를 반복적으로 요청하는 시스템==** 에서 적합하다. 
#### 버디 할당 (Binary Buddy Allocator)![스크린샷 2024-12-22 오후 9.18.03.png](../../Img/스크린샷%202024-12-22%20오후%209.18.03.png)
- 초기 메모리를 **2의 거듭제곱 크기(64KB, 32KB, 16KB 등)의 블록**으로 나누어 관리한다. 
- 메모리 요청이 들어오면 
  1. 적합한 크기의 블록이 있는지 확인
  2. 없으면 더 큰 블록을 **절반으로 분할**하여 사용
  3. **사용 후 해제되면 병합**을 통해 다시 큰 블록으로 통합. 
##### 동작 과정
1. 처음에 64KB 블록이 하나 있다고 가정
2. 7KB 요청이 들어오면: 
   - 64KB → 32KB → 16KB → 8KB로 분할.
   - 요청된 8KB 블록이 할당되고 나머지 블록은 계속 빈 공간으로 유지.
3. 8KB 블록이 해제되면:
   - 인접한 8KB 블록(버디)을 확인하고, 있다면 병합.
   - 이 과정을 반복하여 블록이 다시 64KB로 복구될 수 있음.
→ 메모리 블록의 크기가 일정하므로 관리가 간단하다!
###### 단점
- 요청 크기가 7KB인데 8KB 블록을 사용해야하므로 **내부 단편화 문제**가 발생한다. 

## 20. 4 요약
다양한 워크로드에 대해 빠르고 효율적이고 확장성이 좋은 (scalable) Allocator를 만드는 것이 현대 컴퓨터 시스템의 핵심이자 숙제이다!!










  
  
  






