사용 가능한 락을 만들기 위해서는 우리의 오랜 친구들인 하드웨어와 운영체제의 도움을 받아야 한다. 
어떤 락이든 만들기 전에 첫째로 목표를 이해해야 하고 구현의 효율을 어떻게 평가할지 질문해야 한다. 
1. **상호 배제(mutual exclusion)** 을 제대로 지원하는가
2. **공정성(fairness)** → 쓰레드들이 락 획득에 대한 공정한 기회가 주어지는가? 굶주리는(starve) 경우는 없는가
3. **성능(performance)** → 멀티 CPU, 멀티 쓰레드에서의 상황을 고려
## 28. 1 스핀 락
스핀 락(Spinlock)은 락이 풀릴 때까지 반복적으로 확인(스핀)하며 대기하는 락의 한 종류이다. 
![IMG-20250106143414.png](IMG-20250106143414.png)
위는 `TestAndSet`을 사용하여 간단한 스핀락을 구현한 코드이다. 
#### 스핀 락 동작 과정
1. **락 시도**
	- 쓰레드가 `lock()`을 호출하면 `TestAndSet`을 통해 `flag`값을 확인한다. 
	- `flag`값이 0이면 1로 설정하고 락을 획득한다. 
	- `flag`값이 이미 1이면 락을 얻을 때까지 반복(스핀)한다. 
2. **락 해제**
	- 락을 가진 쓰레드가 `unlock()`을 호출하여 `flag`를 0으로 설정한다. 
	- 다른 대기 중인 쓰레드가 `flag`를 확인하고 락을 획득할 수 있게 된다. 
3. **여러 쓰레드가 동시에 락을 요청**하는 경우
	- 여러 쓰레드가 동시에 락을 요청하면, 성공한 쓰레드만 락을 얻고, 나머지는 스핀 상태로 대기한다. 
###### 스핀 락의 문제점
1. 공정성 문제
	- 특정 쓰레드가 계속 CPU 자원을 우선적으로 배정받는다면 다른 쓰레드가 락을 얻지 못할 수 있다. (starvation 문제) 
2. 성능
	- 스핀락은 **짧은** 임계 구역에 적합하다. 임계 구역이 길 경우, **스핀에 의한 CPU 사용량이 증가**하여 성능이 저하된다. 
## 28. 2 다양한 락
락이 해제되기를 기다리며 스핀하는 경우를 없애기 위해 여러 방법들을 고안해볼 수 있다!
### 1. CPU를 다른 쓰레드에게 무조건적으로 양보
운영체제에 자신이 할당받은 CPU 시간을 포기하고 yield()를 통해 다른 쓰레드가 실행될 수 있도록 한다. 그러나, 어떤 쓰레드는 무한히 양보만 하고 있는 굶주림 문제는 아직 해결이 안된다. 
![IMG-20250106151852.png](IMG-20250106151852.png)
### 2. 큐의 사용: 스핀 대신 잠자기
#### 스핀락의 가장 큰 문제
- 다음 스케줄러가 어떤 쓰레드를 실행시킬지 제어하지 못한다는 점이다. 
- 쓰레드가 락을 얻기 위해 무한히 스핀하면서 CPU를 낭비하는 기아 문제를 해결하기 위해 **쓰레드 대기를 관리하는 큐(queue)를 활용하는 방식**을 도입한다. 
**`park()`와 `unpark()`함수**
- `park()`: 현재 쓰레드를 **일시 중단**(잠자기 상태) 시키는 함수이다. 락을 얻지 못한 쓰레드가 호출하여 대기 상태로 들어간다. 
- `unpark(threadID)`: 특정 쓰레드를 깨워서 실행 대기 상태로 전환시킨다. 
#### 동작 방식
1. 쓰레드 대기를 큐로 관리 
	- 락을 얻지 못한 쓰레드가 무한히 스핀하지 않고, 큐에 등록되어 `park()` 상태로 전환된다. 
	- 락이 해제되면 `unpark()`을 통해 특정 쓰레드를 깨워서 락을 얻도록 한다. 
2. 경쟁 조건 방지
	- `guard`락을 통해 큐 접근 시 경쟁 조건을 방지한다. 
	- 여기서 `guard`락은 큐를 보호하기 위해 추가된 락이다. 
	  → 큐에 쓰레드를 추가하거나, 뺄 때 데이터가 변경됨에 따라 **Race Condition**이 발생할 수 있기에 추가적인 `guard`락을 사용한다. 
3. CPU 낭비 최소화
	- 쓰레드가 `park()` 상태로 대기하므로, CPU를 낭비하지 않는다. 

#### `park()`의 Race Condition 문제
1. **쓰레드 A가 락을 얻으려다가 실패**하여 잠깐 자야겠다 결심하고 `park()`로 들어가려 한다. 
2. 락을 가지고 있던 쓰레드 B는 일을 끝내고 락을 해제한다. 
3. 락을 대기 중이던 A를 깨우려고 `unpark(A)`를 호출한다. 
4. 쓰레드 A가 **아직 완전히 잠자기 상태(`park`)에 들어가기 전에 쓰레드 B가 깨워버린다**. 
5. `unpark(A)`는 쓰레드 A에게 신호를 보냈지만, 쓰레드 A는 아직 잠들지 않았기 때문에 신호를 놓친다. 
6. 이후 쓰레드 A가 진짜로 `park()`로 잠들면, 아무도 쓰레드 A를 다시 깨울 수 없어서 **영원히 잠들어 버리는 문제(deadlock)** 이 발생한다.

#### 이를 해결하기 위한 `setpark()`의 등장
1. 쓰레드 A는 **“나 곧 잠들거야!” 라고 미리 표시**한다. 
2. 쓰레드 A가 잠들기 전에 `setpark()`로 준비 상태를 알렸으니, 쓰레드 B가 `unpark(A)`를 호출하면, 쓰레드 A는 실제로 잠들고, 그냥 깨어 있는 상태로 돌아간다. 
3. 만약 쓰레드 B가 `unpark()`를 호출하지 않았다면, 쓰레드 A는 안전하게 잠자기 상태로 들어간다. 
### 3. 2단계 락
우선 Linux의 경우 `park()`과 비슷하게 `futex`라는 것을 지원한다. 호출자는 `futex`를 호출하여 필요에 따라 잠을 자거나 깨어날 수 있다. 
2단계 락은 `spinlock`과 `futex`의 장점을 결합한 **하이브리드 락 방식**이다. 
**짧은 임계 구역에서는 스핀락**을, **긴 대기 상황에서는 잠자기(futex)** 를 활용한다. 


