**가변 크기의 조각들로 분할**하는 세그멘테이션은 **단편화라는 고질적인 문제**가 존재한다. 
## 21. 1 페이징의 개요
프로세스 주소 공간을 가변 크기의 논리 세그멘트(ex. 코드, 힙, 스택)로 나누는 것이 아니라 **고정 크기의 단위로 나눈다**. 이 고정 크기 단위를 **페이지(page)** 라고 부른다. 

4개의 16바이트 페이지로 구성된 **총 크기가 64바이트인 작은 주소 공간을 예**로 들어 설명해보자!
실제 주소 공간은 훨씬 커서 32bit의 경우 4GB, 64bit의 경우에는 그보다 훨씬 크다. 
![[스크린샷 2024-12-22 오후 11.05.05.png]]
물리 메모리는 고정 크기의 슬롯들로 구성된다. 물리 메모리도 8개의 페이지 프레임, **총 128바이트의 비현실적으로 작은 물리 메모리**를 가진다고 가정하자!
![[스크린샷 2024-12-22 오후 11.06.19.png]]
<그림 21.2> 와 같이 가상 주소 공간 페이지들은 물리 메모리 전체에 분산 배치되어 있다. 
페이징은 이전 방식에 비해 많은 장점들을 가지고 있다. 
1. 가장 뚜렷한 장점은 **유연성**이다. 
	페이징을 사용하면 프로세스 주소 공간의 힙과 스택이 어느 방향으로 커지는지, 어떻게 사용되는지에 대한 가정을 하지 않아도 된다. 
2. 두 번째 장점은 **단순함**이다. 
	64바이트 주소 공간을 물리 메모리를 배치하기를 원한다고 할 때, 운영체제는 비어있는 4개의 16바이트 페이지만 찾으면 된다. 
	→ 이를 위해 운영체제는 모든 비어있는 페이지의 **Free List**를 유지하고, 리스트의 첫 네 개 페이지를 선택할 것이다. 

#### page table
- 운영체제는 ==프로세스마다 **페이지 테이블(page table)**== 이라는 자료 구조를 유지하여 **각 가상 페이지에 대한 물리 메모리 위치를 기록**한다. 
- 페이지 테이블의 주요 역할은 **주소 변환(address translation)** 이다. 각 프로세스의 페이지가 저장된 물리 메모리의 위치가 어딘지 알려준다.  <그림 21.2> 와 같은 경우, (가상 페이지 0 → 물리 프레임 3), (VP 1 → PF 7), (VP 2 → PF 5) 및 (VP 3 → PF 2). 
#### 주소 변환의 원리
가상 주소 공간의 크기가 64바이트이고, 각 페이지는 16바이트의 크기를 가진다 가정하자. 
- 페이지는 총 4(2비트)개가 필요하고, 원하는 바이트의 위치를 나타내는 Offset은 16(4비트)개가 필요하다. 
- 따라서, 가장 주소는 총 6비트가 필요하다($2^6 = 64$)
![[스크린샷 2024-12-23 오후 12.12.48.png]]
![[스크린샷 2024-12-23 오후 12.27.40.png]]
- 위 가상 주소 "21($010101_2$)"는 가상 페이지(VPN: Virtual Page Num) “01”의 5번째(“0101” 번째) 바이트이다. 이 가상 페이지 번호를 통해 **Page Table의 Index**로 이동하여 현재 가상 페이지가 어느 물리 프레임에 저장되어 있는지를 찾을 수 있다. ![[스크린샷 2024-12-23 오후 12.29.58.png]]
  offset은 가상 주소와 동일하다. **offset은 페이지 내에서의 우리가 원하는 위치**를 알려주기 때문이다! 최종적으로 계산된 물리 주소는 “117($1110101_2$)”이고, 이곳이 탑재할 데이터가 저장된 정확한 위치이다!
각 프로세스들은 본인의 데이터가 어디에 저장되는지 모르는 것이 가상화의 중요한 원칙이라고 배웠었다. **그러면 페이지 테이블은 어디에 저장될까?** 

## 21. 2 페이지 테이블은 어디에 저장될까?
페이지 테이블은 매우 커질 수 있다. 
예를 들어, 4KB 크기의 페이지를 가지는 전형적인 32비트 주소 공간에 대해 
이 **가상 주소는 20비트 VPN**과 **12비트 오프셋으로 구성**된다. 

20비트 VPN은 운영체제가 각 프로세스를 위해 관리해야 하는 변환의 개수가 $2^{20}$(약 백만)개라는 것을 의미한다. **페이지 테이블 항목(page table entry, PTE)** 마다 (VM ↔️ PF) 변환 정보를 저장하기 위해 4바이트가 필요하다고 가정하면, 각 페이지 테이블은 4MB(4000000바이트)의 꽤 큰 메모리가 필요하게 된다. 64비트 주소 공간으로 가면 테이블의 크기는 더더욱 커진다. 
![[스크린샷 2024-12-23 오후 12.55.42.png]]
나중에 운영체제 메모리 자체의 많은 부분이 가상화될 수 있기에, 우선은 각 프로세스의 페이지 테이블이 <그림 21.4>와 같이 **운영체제의 메모리 영역에 저장**된다고 생각하자. 활성 프로세스의 페이지 테이블을 메모리에 상주시키고, 비활성 프로세스의 페이지 테이블은 **디스크(스왑 공간)로 옮겨질 수 있다.** 

<그림 21.4>는 **Linear Page Table**로 가장 단순한 형태의 페이지 테이블을 보여준다. 
가상 페이지 번호를 배열의 인덱스로 사용하여 해당 항목에 접근할 수 있다. 

## 21. 3 페이지 테이블에는 실제 무엇이 있는가!?
우선 위에서 다뤘듯, 각 **페이지 테이블 항목(PTE: Page Table Entry)** 에는 가상 페이지 번호(VPN: Virtual Page Number)와 물리 페이지 번호(PFN: Physical Frame Number)를 연결하는 매핑 정보를 포함한다. 추가적으로, **다양한 제어 비트**를 포함한다. 
1. Valid Bit: 해당 페이지가 **유효한지 여부**를 나타냄
   → 페이지가 유효하지 않으면 운영 체제는 트랩을 발생시켜 Segmentation fault를 발생
2. Protection Bit: 해당 페이지가 **읽기, 쓰기, 실행 권한**을 가지고 있는지를 제어
   → 비정상적인 접근 시 트랩을 발생
3. Present Bit: 페이지가 **물리 메모리에 존재하는지 여부**를 나타냄
   → 페이지가 스왑 공간에 있으면 이 비트는 꺼져 있으며, 운영체제는 페이지를 스왑에서 불러온다. 
4. Dirty Bit: 해당 페이지의 **수정 여부**를 나타냄
   → 페이지를 스왑 공간에 저장하기 전에 변경된 데이터를 기록하는 데 사용
5. Reference Bit: 해당 페이지의 최근 참조 여부를 나타냄
   → 페이지 교체 알고리즘 (ex. LRU)에서 활용

## 21. 4 페이징은 느리다
메모리 참조가 이루어질 때마다 CPU는 아래와 같은 작업을 수행해야 한다. 
1. 페이지 테이블에서 가상 주소의 **가상 페이지 번호(VPN)** 을 추출.
2. VPN을 기반으로 **페이지 테이블 항목(PTE)** 를 메모리에서 로드.
3. PTE를 통해 **물리 페이지 번호(PFN)** 을 가져오고, **가장 주소의 오프셋을 결합**해 최종 물리 주소를 생성
4. 해당 물리 주소에서 데이터를 로드. 
→ 모든 메모리 참조에 대해 ==**먼저 페이지 테이블에서 변환 정보를 반입**==해야 하기 때문에 반드시 한 번의 추가적인 메모리 참조가 필요하다. 메모리 참조는 비용이 비싸고, 이 경우에 프로세스는 2배 이상 느려진다. 

## 21. 5 요약
페이징을 제대로 구현하지 못하면 **컴퓨터가 매우 느려지고**(페이지 테이블 접근을 위한 많은 추가적 접근) 뿐만 아니라 **메모리 낭비**(유용한 응용 데이터 대신 페이지 테이블로 가득 참)까지 초래한다. 제대로 동작하는 페이징 시스템 고안을 위해서는 더 많은 노력을 해야 한다. 

다음 두 장을 통해 어떻게 페이징을 다룰지를 설명해보자!