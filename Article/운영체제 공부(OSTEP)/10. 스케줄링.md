## 10. 1 워크로드
일련의 프로세스들이 실행되는 상황을 **워크로드(workload)** 라고 부르기로 한다. 
**워크로드**를 결정하는 것이 정책 개발에 매우 중요한 부분이다. 

시스템에서 실행 중인 프로세스 혹은 작업(job)에 대해 다음과 같은 가정을 한다. 
1. 모든 작업은 같은 시간 동안 실행된다. 
2. 모든 작업은 동시에 도착한다. 
3. 각 작업은 시작되면 완료될 때까지 실행된다. 
4. 모든 작업은 I/O 없이 CPU만 사용한다. 
5. 각 작업의 실행 시간은 사전에 알려져 있다. 

스케줄링에서 성능과 공정성은 서로 상충되는 목표이다. 
성능을 극대화하기 위해 몇몇 작업의 실행을 중지하며, 결과적으로 공정성이 악화된다. 

## 10. 2 스케줄링 알고리즘
### FIFO (=FCFS)
- First In First Out
- First Come First Served
선입선출 알고리즘
![Img/Article/운영체제 공부(OSTEP)/10. 스케줄링/IMG-20241202113535.png](Img/IMG-20241202113535.png)
짧은 시간 동안 자원을 사용할 프로세스들이 오랫동안 사용하는 프로세스의 종료를 기다려야 한다. 

### SJF
- Shortest Job First 
모든 작업이 동시에 도착한다면 SJF가 최적의 스케줄링 알고리즘일 것이다. 
![Img/Article/운영체제 공부(OSTEP)/10. 스케줄링/IMG-20241202113536.png](Img/IMG-20241202113536.png)
![Img/Article/운영체제 공부(OSTEP)/10. 스케줄링/IMG-20241202113537.png](Img/IMG-20241202113537.png)
그러나, B와 C가 A 바로 뒤에 도착한다고 했을 때, A가 끝날 때까지 기다릴 수 밖에 없어서 FIFO 알고리즘에서 생겼던 문제가 동일하게 발생한다.

### STCF
- Shortest Time-to-Completion First
  남아 있는 작업과 새로운 작업의 잔여 실행시간을 계산하고 그 중 가장 적은 잔여 실행 시간을 가진 작업을 스케줄한다. 
![Img/Article/운영체제 공부(OSTEP)/10. 스케줄링/IMG-20241202113538.png](Img/IMG-20241202113538.png)
## 10. 3 새로운 평가 기준: 응답 시간
작업의 길이를 미리 알고 있고, 작업이 오직 CPU만 사용하며, 평가 기준이 반환 시간 하나라면, STCF는 매우 훌륭한 정책이다. 

터미널 앞에 앉아 입력한 후, 단지 다른 작업이 먼저 스케줄 되었다는 이유만으로 시스템의 응답이 올 때까지 오래 기다리는 것을 생각해보면 별로 즐거운 일은 아니다. 

### 라운드 로빈(Round-Robin, RR)

![Img/Article/운영체제 공부(OSTEP)/10. 스케줄링/IMG-20241202113539.png](Img/IMG-20241202113539.png)RR은 작업이 끝날 때까지 기다리지 않는다. 대신 **일정 시간 동안 실행** 후 **실행 큐**의 다음 작업으로 전환한다. 
이때 작업이 실행되는 일정 시간을 `타임 슬라이스(time slice)` 또는 `스케줄링 퀀텀(scheduling quantum)` 이라 부른다. 

타임 슬라이스의 길이는 RR에게 매우 중요하다. 
- 타임 슬라이스가 짧을수록, 응답 시간 기준으로 RR의 성능은 더 좋아진다. 
  그러나, 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 된다. 

응답시간 기준으로는 최적의 정책이라 보이지만, 반환 시간을 측정 기준으로 잡으면 RR은 최악의 정책이 된다. 

## 10. 4 입출력이 있는 프로세스
![IMG-20241202113539-1.png](IMG-20241202113539-1.png)
![IMG-20241202113539-2.png](IMG-20241202113539-2.png)
- A: 10ms 동안 실행된 후, 입출력 요청을 함
- B: 입출력을 수행하지 않음
프로세스의 입출력이 끝나기를 기다리는 동안 CPU는 다른 프로세스에 의해 사용되어 연산의 중첩이 가능해진다. 

## 10. 5 요약
위 일련의 과정들은 스케줄러가 각 작업의 실행 시간을 알고 있다고 가정하고 진행된다. 
그러나 미래를 예측할 수 없는 범용 운영체제에서 작업의 길이에 대해서 알 수 있는 길은 없다. 

가까운 과거를 이용하여 미래를 예측하는 스케줄러를 구현하여 이 문제를 어떻게 해결할 수 있는지 알아보자. **with** `멀티 레벨 피드백 큐(multi-level feedback queue)`


