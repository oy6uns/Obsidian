
> [!TLB] 핵심 질문
> - 주소 **변환 속도를 향상**시킬 수 있을까? 
> - 페이징에서 발생하는 추가 메모리 참조를 **어떻게 피할 수 있을까**? 
> - **운영체제**가 어떤 식으로 **개입**해야 할까?

운영체제의 실행 속도를 개선하기 위해 하드웨어로부터 도움을 받아보자!
우리는 **변환-색인 버퍼(translation-lookaside buffer)** 또는 **TLB**라고 부르는 것을 도입한다!
**TLB**는 MMU(Memory-Management Unit)의 일부이다. 자주 참조되는 Virtual Address-Physical Address 변환 정보를 저장하는 하드웨어 캐시이다. **주소-변환 캐시(address-translation cache)** 가 좀 저 적합한 명칭이다. 

가상 메모리 접근 시 필요한 주소 변환 작업을 **CPU** 내에서 빠르게 처리할 수 있다. 만약 TLB에 변환 정보가 있는 경우(hit!) 메모리를 직접 참조하지 않고도 주소 변환이 가능하다!

## 22. 1 TLB의 기본 알고리즘
주소 변환부가 단순한 **Linear Page Table**에 하드웨어로 관리되는 **TLB**가 추가되어 주소변환 메커니즘이 동작한다고 하자. 
### TLB의 작동 원리
1. 가상 페이지 번호(VPN, Virtual Page Num) 추출
2. 해당 VPN의 TLB 존재 여부를 검사
	- TLB Hit: 변환 정보가 존재하면, **바로 물리 주소를 계산하여 메모리에 접근**한다. 
	- TLB Miss: 변환 정보가 없다면, **페이지 테이블에서 정보를 조회**해야 한다. 
	  → 해당 VPN에 대응하는 페이지 프레임 번호(PFN)를 찾아 변환 정보를 가져오고 메모리에 접근한다. 

- CPU의 캐시와 유사하게 동작하여 메모리 접근 시간을 크게 줄인다. 
- 특히, ==**자주 접근하는 메모리 주소의 변환 정보를 TLB에 유지**==함으로써 성능을 최적화한다.
  → TLB 미스가 많이 발생하는 경우를 최대한 피해야 한다. 
##### 간단한 예시![IMG-20241223180123.png](IMG-20241223180123.png)
배열의 0~9 index의 원소의 합을 구하는 간단한 코드를 동작시킨다 하자. 
![IMG-20241223180123-1.png](IMG-20241223180123-1.png)
가상 주소 공간은 <그림 22.2> 와 같이 16개의 페이지로 구성되어 있다고 하자. 
1. a[0]를 읽는다. TLB Miss → VPN 06을 TLB에 싣는다. 그 다음 a[1], a[2]는 TLB Hit!
2. a[3]를 읽는다. TLB Miss → VPN 07을 TLB에 싣는다. 그 다음 a[4], a[5], a[6]는 TLB Hit!
3. a[7]를 읽는다. TLB Miss → VPN 08을 TLB에 싣는다. 그 다음 a[8], a[9]는 TLB Hit!
**TLB Hit Ratio**는 70%가 된다. <span style="color:rgb(51, 112, 200)">배열의 항목들이 페이지 내에서 서로 인접</span> 해 있기 때문에, 페이지에서 첫 번째 항목을 접근할 때만 TLB Miss가 발생한다. TLB는 이러한 ==공간 지역성(**Spatial Locality**)==으로 인해서 성능을 개선할 수가 있다. 

만약 위의 예제 프로그램이 루프 종료 후에도 배열을 사용한다면, **모든 주소 변환정보가 TLB에 탑재**되어 있기 때문에 성능은 더욱 개선될 것이다. 따라서, TLB가 모든 주소 변환 정보를 저장할 정도로 충분히 크다면, TLB Hit x 10 을 얻어 100%의 TLB Hit Ratio를 얻을 수 있다!! 이 경우에서는 ==시간 지역성(**Temporal Locality**)==로 인해 TLB Hit Ratio가 높아진다. 시간 지역성이란<span style="color:rgb(51, 112, 200)"> 한번 참조된 메모리 영역이 짧은 시간 내에 재 참조되는 현상</span>을 일컫는다. 
→ TLB 의 성공 여부는 프로그램의 **공간 지역성과 시간 지역성 존재 여부**에 달려 있다!

> [!시간&공간 지역성] Spatial & Temporal Locality
> - **Spatial Locality(공간 지역성)**: 프로그램이 메모리 주소 x를 읽거나 쓰면, x와 인접한 메모리 주소를 접근할 확률이 높다는 사실에 근거
> - **Temporal Locality(시간 지역성)**: 최근에 접근된 명령어 또는 데이터는 곧 다시 접근될 확률이 높다는 사실에 근거

어? 그러면 캐시(TLB와 같은)가 그렇게 좋다면, 초대용량 캐시를 제작해서 모든 내용을 저장하면 매우 효과적인 것이 아닌가? 라는 생각을 할 수 있다. 
→ 그러나, **빠른 캐시를 원한다면 크기가 작아야 한다**. 결국에 캐시의 Search Cost도 크기에 비례하기 때문에 크기가 커지면 느려질 수 밖에 없다. 우리가 풀어야할 것은 **“작은” 캐시를 어떻게 “잘” 사용**할 것인가 이다!
## 22. 2 TLB Miss는 누가 처리할까?
두가지 방식이 존재한다. 
- **하드웨어 처리**: CISC(complex-instruction set computers)
	1. CPU가 메모리 주소 변환 요청(TLB 조회)을 보냄.
	2. TLB Miss 발생 시 **하드웨어가 Page Table을 읽어** 변환 정보를 가져옴.
	   → CPU 내부에 위치한 **Memory Management Unit(MMU)** 이 주소 변환과 메모리 접근 권한 확인을 하드웨어적으로 처리한다! CR3 레지스터가 페이지 테이블 주소를 갖고 있다. 
	3. 변환 정보를 TLB에 갱신하고 작업을 재개함.
	→ **처리 속도가 빠르다**, 그러나 설계가 복잡하고 하드웨어가 고정된 방식으로만 동작한다. 
- **소프트웨어 처리**: RISC(Reduced Instruction Set Computing)
	1. TLB Miss 발생 시 **CPU가 운영체제에 trap**을 발생시킴.
	2. 운영체제는 Trap Handler를 실행하여 Page Table을 탐색.
	3. 변환 정보를 읽어와 TLB를 갱신하고 작업을 재개함.
	→ **하드웨어 변경 없이 페이지 테이블 구조를 자유로이 변경할 수 있기에 유연성이 높다**. OS 코드 실행과 Context Switch가 필요하기 때문에 처리속도가 느리다. 

> [!쉽게 이해] 페이징과 TLB 쉽게 이해하기!
> 택배 기사가 원하는 주소로 택배를 배달하고자 한다. 
> - **페이징**: 도시를 동일한 크기의 구역(블록)으로 나누는 것
>   택배 기사는 정확한 집 주소를 알 필요 없이, 먼저 구역을 확인하고, 해당 구역으로 택배를 가져간다. 
> - **세그멘테이션**: 도시를 기능별 구역(상업 지역, 주거 지역,,,,)으로 나누는 것
> - **MMU**: GPS 내비게이션의 기능을 한다. 
>   실제 GPS 좌표(물리 주소)를 목적지 이름(가상 주소)으로 변환해주는 역할을 한다. 
> - **TLB**: 즐겨찾기
>   자주 가는 목적지는 즐겨찾기에 저장해 바로 불러올 수 있다. (TLB 히트)
> - **Page Table**: 실제 지도
>   즐겨찾기(TLB)에 없는 목적지의 좌표를 도로 지도에서 찾아낸다. 

## 22. 3 TLB의 구성: 무엇이 있나?!
![IMG-20241223180124.png](IMG-20241223180124.png)
- TLB는 완전 연관(fully associative) 방식으로 설계된다. 완전 연관 방식에서 **변환 정보는 TLB 어디든 위치할 수 있으며**, 원하는 변환 정보를 찾는 검색은 TLB 전체에서 병렬적으로 수행된다. 
### TLB 엔트리의 다른 비트들
1. **유효 비트(Valid Bit)**: 운영체제가 page table을 수정했거나, 페이지가 더 이상 메모리에 존재하지 않을 경우 해당 비트를 0으로 설정 → 유효성 검증
2. **보호 비트(Protection Bit)**: 페이지 접근 권한을 나타낸다. 
	- 읽기(Read), 쓰기(Write), 실행(Execute) 등
	잘못된 접근(예: 읽기 전용 페이지에 쓰기 시도)이 발생하면 **Page Fault**가 발생한다. 
3. **주소 공간 식별자(Address-Space Identifier, ASID)**
	- 멀티 프로세스 환경에서, 각 프로세스가 서로의 주소 공간을 침범하지 않게 하기 위해 사용
	- **ASID**는 프로세스별로 부여된 식별자로, 특정 TLB 엔트리가 어떤 프로세스에 속해있는지를 나타냄
4. **더티 비트(Dirty Bit)**: 해당 페이지의 최근 수정(Write) 여부
	- 페이지 교체 시, 더티 비트가 설정되어 있으면 페이지를 디스크에 다시 써야 한다. 

## 22. 4 서로 다른 프로세스가 동일한 VPN값을 갖는다면?
TLB에 있는 가상 주소와 실제 주소 간의 변환 정보는 **그것을 탑재시킨 프로세스에서만 유효**하다. 새로운 프로세스에서는 이전에 실행하던 프로세스의 변환 정보(VPN → PFN)을 사용하면 안된다. 

따라서, ==**어떤 프로세스의 Page**를 식별할 수 있도록 TLB 내에 **주소 공간 식별자(Address Space Identifier, ASID) 필드**를 추가==한다. ASID를 통해 동일한 VPN 값을 가지는 **서로 다른 프로세스들이 TLB의 공간을 공유**할 수 있다!
![IMG-20241223180124-1.png](IMG-20241223180124-1.png)
또한, TLB는 두 개의 다른 VPN을 갖는 두 개의 다른 프로세스가 동일한 물리 페이지(PFN)를 가리킬 수 있다. 이러한 경우는 **두 개의 프로세스가 하나의 페이지**(ex. 코드 페이지)**를 공유**하고 있을 때 발생할 수 있다. **공유 페이지**를 사용하면 사용되는 물리 페이지의 수를 줄일 수 있기에 유용하다. 
![IMG-20241223180124-2.png](IMG-20241223180124-2.png)
## 22. 5 TLB 교체(Replacement) 정책
TLB에 새로운 항목을 추가할 때 어떤 항목을 교체해야 할까? 목표는 **미스율을 줄여 (또는 히트 비율을 증가시켜서)** 성능을 개선하는 것이다. 
- LRU: Least Recently Used 
	- 가장 오래 전 사용된 항목을 교체
- Random
	- 임의의 항목을 선택해 교체

## 22. 6 요약
- TLB는 현대 시스템에서 페이징을 지원하기 위한 **필수 요소**로 자리 잡았다. 
- 그러나 TLB는 ==**한계점**==이 존재한다. 
	- 프로그램이 짧은 시간 동안 참조하는 페이지 수가 TLB의 크기를 초과하면 TLB 미스가 빈번히 발생한다. 이러한 현상을 **TLB 범위를 벗어난다**고 표현한다. 
	  → 더 큰 페이지 크기를 지원하면 TLB의 유효 범위가 넓어져 성능을 향상할 수 있다. 
	  → 대규모 데이터 구조를 임의로 접근하는 **DBMS** 같은 프로그램에서 효과적이다. 
	- 캐시를 사용하기 전에 **TLB가 주소를 변환**해야해서 느려진다. 
	  → 변환 과정을 생략하고 가상 주소를 직접 사용하는 캐시 설계. 