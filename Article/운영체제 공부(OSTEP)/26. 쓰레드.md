프로세스를 위한 새로운 개념 **쓰레드(thread)**
하나의 쓰레드의 상태는 프로세스의 상태와 매우 **유사**하다. 
- 쓰레드는 어디서 명령어들을 불러 들일지 추적하는 **프로그램 카운터(PC)** 와 **연산을 위한 레지스터들**을 가지고 있다. 
- 쓰레드가 문맥 교환 시에 T1이 사용하던 레지스터들을 저장하고 T2가 사용하던 레지스터의 내용으로 복원하게 된다. 이때 **쓰레드 제어 블럭(thread control block, TCB)** 를 사용한다. 
- 쓰레드들은 프로그램 코드와 힙을 공유한다. 스택만 쓰레드 개수 만큼 관리된다. 쓰레드의 스택은 **쓰레드-로컬 저장소(thread-local storage)** 로 불린다. 
## 26. 1 쓰레드의 동작
![IMG-20250102170337.png](IMG-20250102170337.png)
<그림 29.3> 에서 나타내는 실행 순서가 쓰레드의 유일한 실행 가능 순서는 아니다. 
생성된 순서와 관계없이 **스케줄러에 의해 늦게 생성된 쓰레드**가 **먼저 출력**될 수도 있다. 

## 26. 2 쓰레드 데이터의 공유
두 thread가 공유 변수인 counter에 각 쓰레드별로 수를 천만 번($1e7$) 더한다고 하자. 
결과적으로 얻으려는 최종 값은 $20,000,000$이다. 
![IMG-20250102171000.png](IMG-20250102171000.png)
그러나, 결과값은 기대한 것보다 작은 $19,345,221$이 나왔다. 
![IMG-20250102171024.png](IMG-20250102171024.png)
왜 이런 일이 일어나는 것일까?

## 26. 3 Race Condition
![IMG-20250102171144.png](IMG-20250102171144.png)
위 예제에서 사용하는 `counter` 변수 위치의 주소는 `0x8049a1c`라고 가정하자. 
1. `counter` 변수의 값을 `%eax`레지스터에 넣는다. 
2. `$eax`의 레지스터 값에 `1`을 더한다. 
3. `%eax`의 레지스터 값을 `counter`변수에 저장한다. 
단일 쓰레드에서 보면 단순한 코드 전개이지만, 2개의 쓰레드에서 동작 시 문제가 발생한다. 

만약, 쓰레드 1의 값이 아직 `counter`변수에 반영되지 않은 상황에서 쓰레드 2가 `counter`변수에 접근할 시 값의 올바른 업데이트가 이루어지지 못한다. **명령어의 실행 순서에 따라 결과가 달라지는 상황**을 ==**경쟁 조건(race condition)**== 이라고 부른다. 

멀티 쓰레드가 같은 코드를 실행할 때 경쟁 조건이 발생할 수 있다.  이처럼 공유 변수를 접근하고 하나 이상의 쓰레드에서 동시에 실행되면 안되는 코드 부분을 ==**임계 영역(critical section)**== 이라고 부른다.
이러한 코드에서 필요한 것은 ==**상호 배제(mutual exclusion)**==이다. 이 속성은 <u>하나의 쓰레드가 임계 영역 내의 코드를 실행 중일 때는 다른 쓰레드가 실행할 수 없도록 보장해준다.</u>

결과적으로 우리는 **운영체제의 지원을 통해** 한 번에 하나의 쓰레드만 임계 영역에서 실행하도록 구성된, “제대로 잘 작동하는” **멀티 쓰레드 프로그램을 설계**해야 한다. 

> [!Atomicity] 원자적 연산(atomic operation)
> 방해 받으면 안되는 연속된 동작들을 원자적으로 만든다는 개념은 간단하게 **“전부 아니면 전무”** 라고 표현할 수 있다. 수행하려는 **모든 동작이 다 처리된 것**처럼 보이거나 실행되다가 만 중간 상태가 없도록 **아무 것도 실행되지 않은 것**처럼 보여야 한다. 

## 26. 4 쓰레드 API
### #1. 쓰레드 생성
![IMG-20250103133041.png](IMG-20250103133041.png)
1. `pthread_t *`: 생성된 쓰레드를 식별하기 위한 변수
2. `pthread_attr_t *`: 쓰레드 속성을 지정하는 구조체 포인터 
   → 쓰레드가 사용하는 **스택 크기**, **스케줄링 정책**, **우선순위** 등을 설정
3. `start_routine`: 쓰레드가 실행할 함수
4. `arg`: `start_routine`에 전달할 데이터
![IMG-20250103134053.png](IMG-20250103134053.png)
### #2. 쓰레드 종료
쓰레드 종료, `pthread_join`이 필요한 이유는 다음과 같다. 
1. 쓰레드가 작업을 끝내기 전에 메인 쓰레드가 종료될 수 있다. ![IMG-20250103144249.png](IMG-20250103144249.png)
2. 쓰레드의 결과 값이 필요한 경우![IMG-20250103144305.png](IMG-20250103144305.png)
3. 리소스 누수를 방지하기 위해
	- 동기화를 하지 않으면 종료된 쓰레드의 자원이 해제되지 않고 누적될 수 있다. 
![IMG-20250103143443.png](IMG-20250103143443.png)
<그림 30.2> 처럼 쓰레드의 값은 **힙**에 할당시켜야 한다. **스택**에 할당 시 **쓰레드가 리턴할 때 자동으로 해제**된다. 현재 해제된 변수를 가리키는 포인터를 반환하는 것은 좋지 않다. 
모든 **멀티 쓰레드 코드가 조인 루틴을 사용하지는 않는다**. 하지만, 특정 작업을 병렬적으로 실행하기 위해 쓰레드를 생성하는 병렬 프로그램의 경우에는 종료 전 혹은 계산의 다음 단계로 넘어가기 전에 **병렬 수행 작업이 모두 완료되었다는 것을 확인**하기 위해 join을 사용한다.

### #3. 락(lock)
`thread_create`, `thread_join` 다음으로 POSIX 쓰레드 라이브러리가 제공하는 가장 유용한 함수는 ==**락(lock)**==을 통한 **임계 영역(critical section)** 에 대한 **상호 배제(mutual exclusion)** 기법이다. 
![IMG-20250103145639.png](IMG-20250103145639.png)
### #4. 컨디션 변수(condition variable)
컨디션 변수는 여러 쓰레드가 협력해야 할 때 **신호를 기다리기**와 **신호를 보내기**를 안전하고 효율적으로 처리할 수 있도록 도와준다. 
![IMG-20250103151350.png](IMG-20250103151350.png)
컨디션 변수를 사용한 프로그램에서 동작 순서는 다음과 같은 패턴 중 하나가 될 수 있다.
#### 가능한 실행 시나리오 1
1. `worker_thread`가 먼저 실행:
    - `worker_thread`는 `ready == 0`을 확인하고, `pthread_cond_wait`로 잠들며 락을 해제한다. 
2. `signal_thread`가 실행:
    - `signal_thread`가 `ready = 1`로 설정하고 `pthread_cond_signal`을 호출한다.
    - `worker_thread`는 신호를 받아 깨어나서 락을 다시 획득한다.
3. `worker_thread`가 다시 실행:
    - 깨어난 후 `ready == 1`임을 확인하고 작업을 계속 진행한다.
4. `signal_thread`는 이미 완료 상태.
---
#### 가능한 실행 시나리오 2
1. `signal_thread`가 먼저 실행:
    - `signal_thread`는 `ready = 1`로 설정하고 `pthread_cond_signal`을 호출한다.
    - 그러나 아직 `worker_thread`가 `pthread_cond_wait` 상태에 들어가지 않았다면, 신호는 아무 효과도 없다.
2. `worker_thread`가 실행:
    - `worker_thread`는 `pthread_cond_wait`을 호출하지만 이미 `ready == 1`이므로 즉시 조건을 통과하여 진행한다.
3. `worker_thread`는 작업을 완료한다. 




