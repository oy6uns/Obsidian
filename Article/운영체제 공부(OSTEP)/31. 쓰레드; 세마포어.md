## 31. 1 세마포어: 정의
정수 값을 갖는 객체로써 두 개의 루틴으로 조작할 수 있다. 
`sem_wait()` 와 `sem_post()`이다. 
세마포어는 초기값에 의해 동작이 결정되기 때문에, 사용하기 전 **”제일 먼저”** 값을 초기화해야 한다. 
![IMG-20250107171951.png](IMG-20250107171951.png)
세마포어를 s로 선언 후, 3번째 인자로 1을 전달하여 세마포어 값을 1로 초기화 한다. 
2번째 인자는 0으로 설정되어 있는데, 이 값은 **같은 프로세스 내의 쓰레드 간에 세마포어를 공유**한다는 것을 의미한다. 
### 세마포어 동작 함수
`{cpp}int sem_wait(sem_t *s)`
- 세마포어의 값을 감소시켜 **자원 사용을 요청**하는 함수
- **동작:**
	- 값이 1 이상: 값을 1 감소시키고 즉시 반환(자원 사용 가능)
	- 값이 0 이하: 대시 상태로 들어감(자원이 사용 중이므로 대기)
`{cpp}int sem_post(sem_t *s)`
- 세마포어 값을 증가시켜 **자원 사용이 끝났음을 알리는** 함수.
- **동작**:
    1. 세마포어 값을 1 증가.
    2. 대기 중인 스레드가 있다면 하나를 깨워 자원을 사용할 수 있도록 함.

## 31. 2 이진 세마포어(락)
이진 세마포어는 락과 동일하게 동작한다. 
![IMG-20250109143203.png](IMG-20250109143203.png)
```cpp
sem_t m;
sem_init(&m, 0, 1); // 세마포어의 초기값을 1로 초기화 
```
- 세마포어의 초기값은 1로 설정되며, 이는 자원 사용이 가능하다는 의미이다. 
- 세마포어 값이 0이면 자원이 이미 사용 중임을 나타내며, 다른 쓰레드는 대기 상태로 들어간다. 
<그림 34.5> 의 메커니즘을 설명하면, 
1. **T0 쓰레드**가 `sem_wait()` 호출 시 세마포어 값은 `1 → 0`으로 감소하며, 임계 영역에 진입한다. 
2. **T1 쓰레드**가 `sem_wait()` 호출 시 세마포어 값이 `0 -> -1`로 변경되고, `sem < 0` 이므로 대기 상태로 전환되고 다시 **T0 쓰레드**로 전환된다. 
3. **T0 쓰레드**가 임계 영역 작업을 마치고 `sem_post()`를 호출하면 세마포어 값이 `-1 → 0`로 증가하고, 대기 중이던 T1이 깨워진다. 
4. **T1 쓰레드**가 본인의 작업을 끝내면, `sem_post()`를 호출하여 세마포어 값을 `0 -> 1`로 증가시키고, 다른 쓰레드가 작업할 수 있게끔 한다. 
## 31. 3 컨디션 변수로의 세마포어
![IMG-20250109145847.png](IMG-20250109145847.png)
특정 조건이 만족될 때까지 현재 쓰레드를 멈추고 기다리게끔 하는 **컨디션 변수** 역할로 **세마포어**를 사용할 수 있다. 
위 <그림 34.6>에서 부모 프로세스는 세마포어를 초기화하고 자식 쓰레드의 작업이 완료될 때까지 `sem_wait`으로 대기한다. 자식프로세스는 `sem_post`를 호출하여 세마포어 값을 증가시킨다. 
두가지 흐름으로 코드가 흘러갈 수 있다. 
1. 부모 → 자식
	- 부모가 `sem_wait`을 호출했을 때 세마포어 값이 `0`이 되므로 대기 상태가 된다. 
	- 자식이 `sem_post`를 호출하면 값이 증가하고 부모가 깨어난다. 
2. 자식 → 부모
	- 자식이 먼저 실행되어 `sem_post`를 호출한다. 
	- 세마포어 값이 `1`로 증가하고, 부모는 `sem_wait`호출 시 즉시 반환한다. 
위처럼 세마포어를 활용하면 쓰레드 간 동기화가 가능해진다. 

## 31. 4 생산자/소비자 (유한 버퍼) 문제
- 생산자와 소비자간 공유된 버퍼를 사용해 데이터를 교환 시에 지난번 단원(condition variables)에서 발생했던 **유한 버퍼 문제가 발생**한다. 
	- **생산자**는 버퍼가 가득 찬 경우 데이터를 추가할 수 없고 대기해야 한다. 
	- **소비자**는 버퍼가 비어 있는 경우 데이터를 가져올 수 없고 대기해야 한다. 
- 이를 해결하기 위해 두 개의 세마포어 `empty`와 `full`이 사용된다. 
	- `{cpp}sem_t empty`: 버퍼에 비어 있는 공간의 개수를 추적한다. 버퍼 공간이 모두 비어있으므로 `MAX`로 초기화된다. 
	- `{cpp} sem_t full`: 버퍼에 채워진 데이터의 개수를 추적한다. 버퍼에 데이터가 없으므로 `0`으로 초기화된다. 
- **생산자 쓰레드**
	- `{cpp}sem_wait(&empty)`로 비어 있는 공간이 있는지 확인 
	- 데이터를 버퍼에 추가
	- `{cpp}sem_post(&full)`로 데이터 추가를 알림
- 소비자 쓰레드
	- `{cpp}sem_wait(&full)`로 데이터가 있는지 확인
	- 데이터를 버퍼에서 가져옴
	- `{cpp}sem_post(&empty)`로 공간이 비워졌음을 알림
#### 발생할 수 있는 문제 상황
- 두 개의 생산자 쓰레드 `Pa`와 `Pb`가 거의 동시에 `put()`함수를 호출한다고 가정
- `Pa`가 `fill` 위치에 데이터를 추가하고 카운터를 갱신하기 전, 인터럽트 발생으로 인해 실행이 중단
- `Pb`가 동일한 `fill`위치에 데이터를 덮어 씌움으로써 `Pa`의 데이터가 `Pb`의 데이터로 덮어씌워져 손실이 발생된다. → **Race Condition** 발생
→ `fill` 변수의 변경과 같은 공유 자원 접근을 보호하기 위해 뮤텍스를 사용한다. 

#### 해결 코드 
![IMG-20250109164002.png](IMG-20250109164002.png)
현재 `empty`, `full` 상태를 producer와 consumer간에 교류하고, 이후에 데이터 접근 시에는 `&mutex`를 통해 순차적으로 동작하게끔 하여 **Race Condition**이 발생하지 않도록 한다. 
만약 아래 코드와 같이 `&mutex`를 먼저 걸어버리면, 현재 데이터의 상태를 producer와 consumer 간에 교류할 수 없기에 **교착 상태(deadlock)** 이 발생하게 된다. ![IMG-20250109164211.png](IMG-20250109164211.png)
## 31. 5 Reader-Writer 락
#### Reader-Writer 문제
- 공유 자원에 대한 **읽기(Read)** 작업은 여러 스레드가 동시에 수행할 수 있지만, **쓰기(Write)** 작업은 하나의 스레드만 독점적으로 수행해야 한다. 
- **Read 작업 중**에는 **Write 작업**이 일어나지 않도록 보장해야 한다. 
- **Write 작업 중**에는 다른 **Read 및 Write 작업이 모두 차단**되어야 한다. 
![IMG-20250109165815.png](IMG-20250109165815.png)
1. `{cpp} void rwlock_acquire_readlock(rwlock_t *rw)`
	1. `{cpp}sem_wait(&rw->lock)`을 통해 기본 락을 잠그고, 읽기 쓰레드 수를 1 증가시킨다. 
	2. `{cpp}rw->readers == 1`이면 읽기 쓰레드가 들어왔다 판단하여 `{cpp}writelock`을 획들하여 쓰기 작업이 진행되지 못하도록 막는다. 
2. `{cpp} void rwlock_release_readlock(rwlock_t *rw)`
	1. 1. `{cpp}sem_wait(&rw->lock)`을 통해 기본 락을 잠그고, 읽기 쓰레드 수를 1 감소시킨다. 
	2. `{cpp}rw->readers == 0`이면 마지막 읽기 쓰레드가 나갔다고 판단하여 `{cpp}writelock`을 해제하여 쓰기 작업이 가능하도록 만든다. 
위 reader-writer 락은 잘 동작하지만, 읽기 작업이 중첩됨에 따라 (`{cpp}rw->readers++`) 쓰기 작업은 계속 대기 상태에 놓이는 **기아 문제(starvation)** 이 발생할 수 있다. 

## 31. 6 교착 상태 ![IMG-20250109170710.png](IMG-20250109170710.png)
철학자 0이 포크 0을 잡고, 철학자 1이 포크 1을 잡고, 철학자 2가 포크 2를, 철학자 3은 포크 3을, 그리고 철학자 4는 포크 4를 잡는다. 모든 포크는 다 누군가 잡고 있기 때문에 **모든 철학자는 다른 철학자가 밖고 있는 포크를 기다리며 대기**하게 된다. 이러한 현상을 ==**교착상태(deadlock)**==이라고 한다. 

이 문제를 해결하기 위한 가장 간단한 방법은 최소한 하나의 철학자가 다른 순서로 포크를 집도록 하면 된다. ![IMG-20250109170949.png](IMG-20250109170949.png)
마지막 철학자가 오른쪽의 포크를 먼저 잡기 때문에, 각 철학자가 하나의 포크를 든 채로 다른 포크를 무한정 기다르는 대기 상황은 발생하지 않는다. 

## 31. 7 총 정리
- **Lock(Mutex)**: 단순 Lock변수(key)를 기반으로 한 상호배제(mutual exclusion)기능을 제공하는 API
  → 한 쓰레드가 사용 중에는 그 키를 사용하고, 돌려주지 않는다. 
- **컨디션 변수(Condition Variables)**: 세마포어를 쓰레드별로 순서를 강제할 때 사용할 수 있다. 
- **세마포어(Semaphore)**: int형 변수(sem)를 통해 lock부터 condition variables의 기능까지 작동시킬 수 있는 API
  → 다양한 동시성 상황에 대해서 대비 가능하다. 
