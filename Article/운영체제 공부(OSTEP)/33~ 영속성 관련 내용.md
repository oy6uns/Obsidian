## 분산 공유 메모리(DSM: Distributed Shared Memory)
사용자 입장에서는 모든 데이터가 하나의 커다란 메모리 공간에 저장된 것처럼 보이지만, 실제로는 여러 노드에 분산되어 있다. 여러 노드(기계)에 걸쳐 있는 데이터를 **단일한 메모리 공간으로 접근할 수 있도록 제공하는 기술**이다. 

### 운영체제 기반 DSM
- OS의 **가상 메모리 시스템**을 기반으로 구현
- **각 노드의 가상 메모리 시스템**이 **네트워크를 통해 데이터를 요청하거나 제공**하는 역할을 수행한다. 
	- 예: **page fault를 활용**해, 로컬에 없는 메모리 페이지를 원격에서 가져온다. 
###### 단점
- 가상 메모리 시스템 위에서 동작하기 때문에 **페이지 단위 데이터 이동**으로 인해 네트워크 대역폭을 많이 소비한다. 
- 특정 **운영체제나 하드웨어에 종속**되기 때문에, 다양한 환경(클라우드, 컨테이너)에서 사용하기 어렵다. 

### 프로그래밍 언어 기반 DSM
- OS 대신, 프로그래밍 언어가 자체적으로 제공하는 **API**나 **라이브러리**를 활용한다. 
	- 분산 시스템에서 다른 컴퓨터의 **메서드(함수)** 를 호출(Java RMI)
	- 여러 프로세스가 데이터를 공유하면서 작업을 처리하도록 도움(Python multiprocessing)
- **데이터 구조와 알고리즘 수준**에서 최적화할 수 있어 성능이 더 뛰어나다. 
###### 단점
- 데이터를 여러 컴퓨터에서 공유하므로, **동시에 같은 데이터를 수정하면 충돌**이 생길 수 있다. 

> [!IMPORTANT] 현대의 대부분 DSM 시스템은 프로그래밍 언어 기반으로 동작한다. 
> 현대 분산 시스템은 **마이크로서비스 아키텍쳐**, **클라우드 네이티브 환경** 등을 지향한다. 프로그래밍 언어 기반 DSM은 이러한 환경에서 ==더 유연하게 사용할 수 있다==. 또한, 설정이 어렵고 디버깅이 복잡한 OS 기반 DSM과 달리 개발자에게 더 익숙한 도구와 환경을 제공해 운영 부담을 줄일 수 있다!

## Remote Procedure Call (RPC: 원격 프로시저 호출)
### RPC의 개념
> **네트워크 상의 다른 컴퓨터에서 동작하는 함수**를 마치 **로컬 함수처럼 호출**할 수 있게 만드는 기술

일반적으로 **프로세스(Process)** 는 **자신의 주소공간 안에 존재하는 함수만 호출하여 실행 가능**하다. 
그러나, **RPC**의 경우 **자신과 다른 주소공간에서 동작하는 프로세스의 함수를 실행할 수 있게 해주는데**, 이는 네트워크를 통한 메시징을 수행하기 때문이다.
- 예를 들어, `{cpp}add(5, 10)`이라는 함수가 실제로는 원격 서버에서 실행되지만, 로컬 함수 호출처럼 보이게 된다. 
- 요즘 유행하는 MSA(Micro Service Architecture)구조의 서비스를 만들 때, 언어나 환경에 구애받지 않고, 비즈니스 로직을 개발하는데에 집중할 수 있다!
### RPC의 구성 요소
![IMG-20250113170821.png](IMG-20250113170821.png)
1) 스텁(Stub)
	- 클라이언트와 서버의 요청 및 응답 메시지를 자동으로 생성하고 처리한다. 
	- 데이터를 **직렬화(Serialization)** 하여 네트워크로 전송하고, 다시 **역직렬화(Deserialization)** 한다. 
	- **스텁의 장점**
		1. 함수 호출 단순화: 사용자는 네트워크 관련 세부사항을 신경 쓸 필요가 없다.  
		2. 자동화: 함수 인자들을 묶어서 네트워크 메시지를 만든다. 
	- **스텁의 단점**
		1. 복잡한 데이터 전달의 어려움: 다차원 배열이나 객체와 같은 복잡한 데이터 구조를 전달하는 것은 어렵다. 
		2. 병행성 문제: 동시에 여러 요청을 처리하려면 서버가 **멀티쓰레드** 혹은 **비동기 모델**로 설계되어야 한다. 
	- 함수명, 인자, 반환값에 대한 데이터 타입이 저장된 IDL 파일을 ==rpcgen 컴파일러==를 이용하여 Stub 코드를 자동으로 생성
	  → * IDL(Interface Definition Language): 인터페이스 정의 언어. 어느 한 언어에 국한되지 않는 언어 중립적인 방법으로 인터페이스를 표현함으로써, 구현 언어(C, C++, Java 등)가 아닌 ==**정의 언어**==로써, **구현 언어로의 매핑(mapping)을 지원**
2) RPC 런타임(Runtime)
	- 호출된 함수의 정보와 데이터를 클라이언트와 서버 간 네트워크로 보내고, 결과를 다시 수신한다. 
### RPC의 단점
1. 네트워크 의존성:
	- RPC는 네트워크가 중단되면 동작하지 않는다. 
2. 성능 문제:
	- 로컬 함수 호출에 비해 네트워크 전송 비용이 추가로 발생한다. 
3. 복잡한 설계 필요:
	- 서버 병렬 처리, 데이터 직렬화, 신뢰성 보장 등 다양한 설계 요소가 추가된다. 

## NFS(네트워크 파일 시스템)
NFS(Network File System)는 **분산 파일 시스템**으로 여러 클라이언트가 네트워크를 통해 **원격 파일을 로컬 파일처럼 공유**하고 사용할 수 있도록 만들어졌다. 
![IMG-20250113182747.png](IMG-20250113182747.png)
기본적으로 클라이언트/서버 기반의 분산 파일 시스템에서는 
- 클라이언트 측의 파일 시스템
- 파일 서버
의 두 가지 핵심적인 소프트웨어가 있어야 한다. 
### NFS의 특징
1) 파일 공유
	여러 클라이언트가 하나의 파일 서버를 통해 **동시에 같은 파일**을 공유할 수 있다. 
	**파일 관리를 중앙화**하고, 데이터를 여러 클라이언트 간에 쉽게 공유할 수 있다. 
2) 투명성
	클라이언트는 파일이 로컬에 있는지 원격에 있는지 신경 쓸 필요가 없다. 
	사용자는 **원격 파일 시스템을 로컬 파일 시스템처럼 사용**할 수 있다. 
3) 네트워크 계층 기반
	일반적으로 TCP나 UDP 프로토콜을 통해 신뢰성 있는 데이터 전송을 보장한다. 
4) 다양한 운영 체제에서 동작하도록 설계되었다. 
## NFSv2
> NFA의 Statefull Design 대신 **Stateless Design** 도입
> 서버는 클라이언트 상태를 저장하지 않는다. 

### NFSv2의 장점
1. 클라이언트가 요청을 보낼 때마다 모든 정보를 포함하여 요청을 전송한다. 
2. 서버가 크래시 후 재부팅 되어도 상태를 복구할 필요가 없기에 단순하다. 
3. 클라이언트의 상태를 추적하지 않으므로 더 많은 클라이언트를 처리할 수 있다. 
### 주요 구성과 특징
1. NFSv2에서 **파일 핸들(File Handle)** 은 특정 파일이나 디렉터리를 고유하게 식별하는 데이터 구조이다. 파일 핸들은 아래와 같은 구성요소로 이루어져있다. 
	- **볼륨 식별자**: 파일이 저장된 특정 파일 시스템이나 디스크 볼륨을 식별
	- **아이노드 번호**: 파일 시스템 내에서 파일이나 디렉토리를 식별
	- **생성 번호** : 파일이 삭제된 후 아이노드가 재활용되는 경우를 구분하기 위해 사용
2. 서버 고장에 대한 멱등성
	동일한 연산을 여러 번 수행하더라도 결과가 변하지 않도록 하는 성질을 의미한다. 
	네트워크 오류나 서버 고장 등으로 인해 요청이 실패했을 경우 동일한 요청을 재전송한다. 
3. 성능 개선: 클라이언트 측 캐싱
	NFS와 같은 분산 파일 시스템은 파일에 대한 읽기/쓰기 요청이 네트워크를 통해 이루어지기 때문에 **성능 문제가 발생**할 수 있다. 이를 해결하기 위해 자주 사용되는 데이터를 로컬에 저장하여 네트워크 왕복 시간을 줄이는 **캐싱**을 활용한다. 
### 캐시 일관성 문제
캐싱은 성능을 향상시키는 데 유용하지만, 캐시된 데이터가 오래되거나 다른 클라이언트의 최신 변경 사항을 반영하지 못할 경우 문제가 발생한다. 이는 **캐시 일관성 문제**라고 한다. 
- **다른 클라이언트가 데이터를 수정했을 때**: 캐시에 저장된 데이터는 여전히 이전 상태를 유지하고 있을 수 있다. 
- **오래된 캐시 데이터 사용**: 캐시에 저장된 데이터가 서버의 최신 데이터를 반영하지 않을 수 있다, 
### NFSv2의 캐시 일관성 유지 방안
1. **Flush-on-Close Semantics(종료 시 플러시)**
   파일이 닫힐 때, 클라이언트는 캐시에 저장된 변경 내용을 서버로 전송하여 데이터를 동기화한다. 
2. **변경 여부 확인**
   파일에 접근하기 전에 클라이언트는 서버에 요청을 보내 해당 파일이 변경되었는지 확인한다. 이 과정을 통해 캐시에 저장된 데이터가 최신 데이터인지 검증한다. 
![IMG-20250113183408.png](IMG-20250113183408.png)
## 정리
##### 분산 공유 메모리(DSM: Distributed Shared Memory)
DSM은 ==여러 노드에 분산된 데이터를 사용자에게 단일 메모리 공간처럼 제공==하는 기술 
**운영체제 기반 DSM**은 가상 메모리를 활용해 데이터를 네트워크로 요청/제공하지만, 페이지 단위 통신으로 인해 네트워크 대역폭 소모가 크고 특정 환경에 종속적이다. 
**프로그래밍 언어 기반 DSM**은 API와 라이브러리를 통해 데이터 공유와 최적화를 지원하며, 현대 클라우드 네이티브 환경에 적합합니다.
##### 원격 프로시저 호출(RPC: Remote Procedure Call)
RPC는 ==네트워크 상의 다른 프로세스의 함수를 로컬 함수처럼 호출==할 수 있는 기술이다. 
**스텁**은 요청/응답 메시지를 생성하며 데이터 직렬화/역직렬화를 처리한다. 
RPC는 설계 복잡성과 네트워크 의존성이 단점이지만, 마이크로서비스 아키텍처 구현에 널리 사용된다. 
##### 네트워크 파일 시스템(NFS: Network File System)
NFS는 클라이언트가 ==네트워크를 통해 원격 파일 서버의 파일들을 로컬 파일처럼 사용하는 분산 파일 시스템==이다. 
NFSv2는 **Stateless Design**을 도입하여 단순성과 확장성을 높였으며, 클라이언트 캐싱으로 성능을 개선했다. 
캐싱으로 발생하는 **캐시 일관성 문제**는 파일 닫기 시 데이터 동기화나 서버 변경 여부 확인으로 해결한다. 