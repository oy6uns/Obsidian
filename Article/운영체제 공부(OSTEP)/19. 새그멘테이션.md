세그멘테이션은 메모리 관리 기법 중 하나로, 하나의 연속된 메모리 공간을 여러 개의 **세그먼트**로 나누어 관리하는 방식이다. 
일반적으로 세그멘트는 프로그램을 코드, 데이터, 힙, 스택 등으로 나누며, 각 세그먼트는 고유한 **베이스 주소(base address)** 와 **오프셋(Offset)** 을 가진다. 
![600](../../Excalidraw/19.1,%202.md)

<그림 19.3>에서 볼 수 있듯이, 사용 중인 메모리에만 물리 공간이 할당된다. 
사용되지 않은 영역이 많은 대형 주소 공간을 **sparce address space**라고 부른다. 
위의 예제의 경우 **3쌍의 베이스와 바운드 레지스터 집합**이 필요하다. 

1KB = 1024byte
1. 가상 주소 100번지 참조 
	- 가상 주소 100번지는 코드 세그먼트에 속한다. 
	- 코드 세그먼트의 **Base Address**는 32KB(32786번지) 이다. 
	- 물리 주소는 **32KB + 100** = 32868번지가 된다. 
2. 가상 주소 4200번지 참조
	- 가상 주소 4200번지는 **힙 영역**에 속한다. (힙의 시작 가상 주소: 4096번지(4KB))
	- 힙의 Base Address는 34KB(34816번지) 이다. 
	- 가상 주소 4200은 실제 4096번지 이후의 104번째 바이트를 참조하는 것이다. 
	- 따라서, 물리 주소는 **힙의 베이스 주소(34KB)** 와 **오프셋(104)** 를 더한 **34816+104 = 34920 번지**가 된다. 
	→ 만약 ==힙의 마지막을 벗어난 7KB와 같은 잘못된 주소를 접근==하려고 하면 하드웨어가 그 주소가 범위를 벗어났다는 것을 감지하고 ==운영체제에 트랩을 발생==시킨다. 
	→ 이것이 그 유명한 **Semgent Fault**이다. 

어 그런데, 가상 주소가 주어졌을 때, **하드웨어가 어떤 종류의 세그먼트인지를 알 수 있는 방법이 없다**!
따라서, 우리는 가상 주소의 ==최상위 비트에 어떤 종류의 세그먼트인지를 명시==해주어야 한다!!

## 19.1 세그멘트 종류의 파악
예를 들어, 14비트 가상 주소 중 **최상위 2비트를 사용**하여 3개의 **세그멘트를 구분**한다고 하자. 
- 00: 코드 세그멘트
- 01: 힙 세그멘트
- 10: 스택 세그멘트
![스크린샷 2024-12-02 오후 6.48.23.png](스크린샷%202024-12-02%20오후%206.48.23.png)
최상위 2비트를 이용해 세그멘트를 구분하고, 나머지 12비트는 해당 세그멘트 내에서의 **오프셋(offset)** 을 나타낸다. 이 오프셋은 해당 세그멘트 내에서 주소가 어디에 위치하는지를 알려줄 수 있다. 
#### 주소 변환 과정
위에 <그림 19.3>을 토대로 설명한대로 가상 주소를 물리 주소로 변환하는 과정은 다음과 같다. 
1. **가상 주소**에서 최상위 비트로 세그멘트를 구분합니다.
2. 세그멘트 종류에 따라 **베이스 주소**와 **바운드**(세그멘트의 크기)를 세그멘트 레지스터에서 찾습니다.
3. 주소가 세그멘트의 범위 안에 있는지 확인합니다. 
   → **바운드 검사**를 통해 유효한 주소인지를 체크
4. 유효한 경우, **오프셋**을 이용해 **베이스 주소**에 더하여 물리 주소를 계산합니다.
#### 스택 세그멘트
일반적인 세그멘트는 앞방향(양의 방향)으로 증가하는데, **스택 세그멘트는 뒤방향(음의 방향)으로 증가**한다. 이로 인해, 스택의 가상 주소를 물리 주소로 변환할 때는 **음수 오프셋을 사용**해야 할 수 있다. 

예를 들어 **3KB**만큼 데이터를 저장한다고 하면, 물리 주소가 **28KB → 25KB**로 이동한다. 
이 경우, 3KB의 오프셋이 ==음수(-3KB)==로 나타나게 된다. 

## 19. 2 중간 요약
가상 주소는 
- ==**세그먼트 종류**(세그먼트 번호)==
  → 최상위 몇 비트를 통해 어떤 종류의 세그먼트(코드, 데이터, 스택 등)를 참조하는지를 결정
- ==**세그먼트 오프셋**(세그먼트 내 위치) ==
  → 세그먼트 내에서 데이터가 위치한 상대적인 주소
으로 나누어져 하드웨어에 제공된다. 

하드웨어는 이 정보를 바탕으로 해당 프로세스의 PCB에 담긴 **세그멘트 레지스터**를 참고하여 **베이스**와 **바운드** 값을 사용해 **적절한 물리 주소로 변환**하는 방식이다. 

## 19. 3 공유 지원
### 1. 메모리 공유 지원
세그멘테이션 기법이 발전함에 따라 시스템 설계자들은 
“**메모리를 절약**하기 위해 때로는 **주소 공간들 간에 특정 메모리 세그멘트를 공유**하는 것이 유용” 하다는 것을 알게 되었다. 

예를 들어, 여러 프로세스가 동일한 **코드 세그멘트**를 읽기 전용으로 공유하면서도 각 프로세스는 여전히 **자신만의 독립적인 메모리 공간**을 갖는 것 처럼 동작한다. 
- - - 
더 자세히 예를 들어보면, 
두 개의 프로그램이 실행되고 있다고 가정해보자. 
하나는 웹 서버 프로그램이고, 다른 하나는 파일관리 프로그램이다. 

이 두 프로그램은 각기 다른 일을 하지만, 모두 **파일을 읽고 쓰는 함수를 공통으로 사용**한다고 가정하자. 
세그멘트 공유 방식을 활용하면, 이 코드 세그멘트는 하나의 메모리 영역에만 저장되어 두 프로그램에서 공유할 수 있다. 이를 통해 코드 세그멘트의 크기를 절반으로 줄일 수 있다. 
### 2. 보호 비트 
세그멘트를 공유함에 따라, 보호의 중요성도 커졌다. 
세그먼트 보호를 위해 하드웨어에 **보호 비트(Protection Bit)** 를 추가할 수 있다. 
이 비트는 세그먼트에 대한 **접근 권한을 결정**한다. 
- **읽기-실행**: 코드 세그멘트와 같이 읽기와 실행만 허용하고 쓰기는 금지한다. 
- **읽기-쓰기**: 힙이나 스택처럼 읽기와 쓰기를 모두 허용한다. 
→ 보호 비트 덕분에, 운영체제는 주소 공간의 독립성을 유지하면서도 실제로 여러 프로세스가 같은 세그멘트를 공유하게 만들 수 있게 되었다!!
![스크린샷 2024-12-02 오후 7.27.02.png](스크린샷%202024-12-02%20오후%207.27.02.png)
## 19. 4 운영체제의 지원
전체 주소 공간이 하나의 베이스-바운드 쌍을 가지는 방식에 비해 
시스템이 각 주소 공간 구성요소를 별도로 물리 메모리에 재배치하기 때문에 
**물리 메모리를 엄청나게 절약**할 수 있게 되었다!!

운영체제는 문맥 교환 시에 새로운 프로세스가 다시 실행하기 전에 
==세그멘트 레지스터의 저장과 복원==을 올바르게 시행해야 한다. 
#### 세그멘테이션은 새로운 문제를 제기한다. 
바로 =="**미사용 중**인 물리 메모리 공간의 관리”== 문제이다. 
예전에는 주소공간의 크기가 동일하다고 가정했지만, 지금은 프로세스가 많은 세그멘트를 가질 수 있고, 각 세그멘트는 크기가 다를 수 있다. 

일반적으로 생길 수 있는 문제는 **물리 메모리가 빠르게 작은 크기의 빈(미사용) 공간들로 채워진다**는 것이다. 이 작은 빈 공간들은 **1) 새로이 생겨나는 세그멘트에 할당하기도 힘들거니**와 **2) 기존 세그멘트를 확장하는 데에도 도움이 되지 않는다**. 
→ 우리는 이 문제를 ==외부 단편화(external fragmentation)==라고 부른다
![스크린샷 2024-12-02 오후 7.39.54.png](스크린샷%202024-12-02%20오후%207.39.54.png)
위의 그림에서 새로운 프로세스가 생성되어 20KB를 할당하려고 한다고 가정하자. 
24KB의 빈 공간이 존재하기는 하지만 하나의 연속된 공간이 아니라 세 개의 청크(chunk)로 나누어져 있다. 
이 문제의 해결책 중 한 가지는 기존의 세그멘트를 정리하여 ==**물리 메모리를 압축**==하는 것이다. 
1. 운영체제는 현재 실행중인 프로세스를 중단하고
2. 그들의 데이터를 하나의 연속된 공간에 복사하고, 
3. 세그멘트 레지스터가 새로운 물리 메모리 위치를 가리키게 하여,
   큰 빈 공간을 확보할 수 있다. 
그러나, 세그멘트 복사는 **메모리에 부하가 큰 연산**이고, 일반적으로 상당량의 프로세서 시간을 사용하기 때문에 **압축은 비용이 많이 든다**. 
이를 해결하기 위해**최적 적합(best-it), 최악 적합(worst-fit), 최초 적합(first-fit) 및 버디 알고리즘(buddy algorithm)** 등 아주 많은 방식들이 존재한다. 
그러나, 알고리즘이 아무리 정교하게 동작한다고 해도 외부 단편화는 여전히 존재한다 ㅠㅠ
## 19. 5 요약
- 세그멘테이션은 물리적 공간의 낭비를 해결하며, 메모리 가상화를 효과적으로 실현할 수 있다. 세그멘테이션에 필요한 연산을 쉽고 빠르며, 코드 공유의 장점도 가지고 있다. 
- 그러나, 세그멘트의 크기가 일정하지 않기 때문에 몇 가지 문제가 발생한다. 
	1. 외부 단편화(External Fragmentation)
	2. 실제로는 드물게만 사용되는 메모리 영역도 항상 물리 메모리에 있어야 한다는 점이다. 
	   예를 들어, 프로그램에서 100KB 크기의 힙을 할당했다고 가정하자. 
	   그런데 이 힙 전체가 모두 사용되는 것이 아니라, 일부 영역만 사용될 수 있다. 
	   하지만, 세그멘테이션에서는 100KB 크기의 힙 전체를 물리 메모리에 할당해야 한다. 
	   즉! 사용되지 않는 부분도 물리 메모리에 계속 남아 있어야 하기 때문에 비효율적이다.
##### 이를 해결하기 위해 메모리를 좀 더 세밀하게 관리할 수 있는 방법이 필요하다. 
1. 세그멘트를 더 작은 단위로 나누어서 비어있는 공간이 생기지 않도록 하기
2. 진짜 필요한 부분만 메모리에 로딩하기

… next class






