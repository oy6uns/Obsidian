지금까지는 **실행 중인 프로세스의 전체 주소 공간이 메모리에 탑재**된 것을 가정하고 있었다. 
이제는 **다수 프로세스들이 동시에 각자 큰 주소 공간을 사용**하고 있는 상황을 가정한다. 

큰 주소 공간을 지원하기 위해 운영체제는 주소 공간 중에 **현재는 크게 필요하지 않은 일부를 보관해둘 공간**이 필요하다. 현대 시스템에서는 보통 **하드 디스크 드라이브**가 이 역할을 담당한다. 
메모리 계층에서 크고 느린 하드 디스크 드라이브가 **가장 하부에 위치**하고, **그 위에 메모리**가 있다. 

> 운영체제는 어떻게 크고 느린 장치를 사용하면서 **마치 커다란 가상 주소 공간이 있는 것**처럼 할 수 있을까?

==스왑 공간==이 추가되면 운영체제는 실행되는 각 프로세스들에게 큰 가상 메모리가 있는 것 같은 환상을 줄 수 있다. **멀티프로그래밍 시스템**이 발명되면서 **많은 프로세스들이 페이지를 물리 메모리에 전부 저장하는 것이 불가능**하게 되었고, ==일부 페이지들을 스왑 아웃==하는 기능이 필요하게 되었다. **실제 물리 메모리보다 더 많은 용량이 메모리**가 필요하게 되었고, 이것이 현대 ==**Virtual Memory**==의 역할이다. 

## 24. 1 스왑 공간
가장 먼저할 일은 디스크에 페이지들을 저장할 수 있는 일정 공간을 확보하는 것이다. 이 용도의 공간을 **==스왑 공간(Swap Space)==** 이라고 한다. 메모리 페이지를 읽어서 이곳에 쓰고(swap out), 여기서 페이지를 읽어(swap in) 메모리에 탑재시키기 때문이다. **운영체제**는 **스왑 공간에 있는 모든 페이지들의 디스크 주소를 기억**해야 한다. 

스왑 공간의 크기는 매우 중요하다. 시스템이 사용할 수 있는 메모리 페이지의 최대수를 결정하기 때문이다. 문제를 단순화 하기 위해, **스왑 공간은 매우 크다고 가정**하자. 
![[IMG-20241226142502.png]]
<그림 24.1> 에서 물리 메모리와 스왑 공간에는 각각 4개의 페이지와 8개의 페이지를 위한 공간이 존재한다. 세 개의 프로세스(Proc 0, Proc 1, Proc 2)가 물리 메모리를 공유하고 있다. 세 프로세스는 몇 개의 유효한 페이지들만 메모리에 올려 놓았으며 나머지 페이지들은 디스크에 스왑 아웃되어 있다. 
네 번째 프로세스(Proc 3)는 모든 페이지가 스왑 아웃 되어 있다. 

## 24. 2 Present Bit
메모리가 참조되는 과정을 상기해보자. 
- 하드웨어는 먼저 가상 주소에서 VPN을 추출한 후에 TLB에 해당 정보가 있는지 검사한다. **TLB 히트**가 되면 물리 주소를 얻은 후에 메모리로 가져온다. 
- VPN을 TLB에서 찾을 수 없다면(**TLB 미스**), 하드웨어는 VPN을 인덱스로 하여 페이지 테이블을 탐색하여 원하는 **페이지 테이블 항목(PTE, Page Table Entry)** 을 추출한다. 이후 PTE로부터 추출한 PFN 정보를 TLB에 탑재 후 명령어를 재실행한다. 
- 하드웨어는 **present bit**를 사용하여 페이지가 물리 메모리에 있는지, 스왑 공간에 있는지를 구분한다. 
	- 물리 메모리 `present bit = 1`, 스왑 공간 `present bit = 0`
- 물리 메모리에 존재하지 않는 페이지를 접근 시 **페이지 폴트(page fault)** 가 발생하고, 이를 처리하기 위해 운영체제에게 제어권을 넘기는 **페이지 폴트 핸들러(page fault handler)** 가 실행된다. 
  → page fault는 흔히 “오류”로 불리지만, 잘못된 접근이 아니라 **정상적인 가상 메모리 시스템의 동작**이다. 하드웨어와 운영체제가 협력하여 문제를 처리하기 때문이다. 

## 24. 3 Page Fault
TLB 미스의 처리 방법은 크게 하드웨어 기반과 소프트웨어 기반 두 종류가 있었다. 
둘 중 어느 것이던, **page fault**가 발생하면 운영체제가 그 처리를 담당한다. 운영체제의 **page fault handler**가 그 처리 메커니즘을 규정한다!!

만약 요청된 페이지가 메모리에 없고, 디스크로 스왑되었다면, 운영체제는 해당 페이지를 메모리로 스왑해온다. 그러면 원하는 페이지의 위치를 어떻게 파악할까?

많은 시스템들에서 **해당 페이지의 스왑 공간상에서의 위치**를 페이지 테이블에 저장한다. 
1. **page fault** 발생 시, 운영체제는 **page table entry(PTE)** 에서 **해당 페이지의 디스크 상 위치(PFN)를 파악**하여 메모리로 탑재한다. 
2. 디스크 I/O가 완료가 되면 운영체제는 해당 페이지의 PTE의 PFN 값을 **탑재된 페이지의 메모리 위치로 갱신**한다. 
3. 이 작업이 완료되면 **page fault**를 발생시킨 명령어가 재실행된다. 재실행으로 인해 TLB 미스가 발생될 수 있다. TLB 미스 처리 과정에서 TLB 값이 갱신된다. 
   → 2번 과정 시행 시에 TLB 값까지 한 번에 갱신시키도록 할 수도 있다. 
4. 마지막 재실행 시에 **TLB에서 주소 변환 정보를 찾게** 된다. 
I/O 전송 중에는 해당 프로세스는 **차단된(blocked)** 상태가 된다. I/O 실행은 매우 시간이 많이 소요되기 때문에 한 프로세스의 I/O 작업(예: page fault)과 다른 프로세스의 실행을 중첩(overlap) 시키는 것은 멀티프로그램 시스템에서 하드웨어를 최대한 효율적으로 사용하는 방법이다. 

## 24. 4 메모리에 빈 공간이 없다면?
스왑 공간으로부터 페이지를 가져오기 위한(page-in) 여유 메모리가 충분할 때는 문제가 없이 위의 과정들이 잘 시행된다. 그러나, **메모리에 여유 공간이 없을 경우** 탑재하고자 하는 새로운 페이지들을 위한 공간을 확보하기 위해 하나 또는 그 이상의 페이지들을 먼저 **page-out** 시켜야 한다. **교체할 페이지를 선택하는 것**을 **페이지 교체 정책(page-replacement policy)** 라고 한다. 

잘못되니 페이지 교체 정책을 고를 경우, 프로그램이 **메모리 속도로 실행되는 것**이 아니라 **디스크와 비슷한 속도**로 동작할 수도 있기 때문이다. 프로그램이 약 10,000~100,000배 더 느리게 실행된다는 것을 의미한다. 
![[IMG-20241226162550.png]]
<그림 24.2>에서 발생한 **page fault**는 OS의 **page fault handler**에 의해 <그림 24.3>과 같이 처리된다. 
![[IMG-20241226162702.png]]
## 24. 5 교체는 언제 일어날까?
위의 설명에서는 **메모리에 여유 공간이 고갈될 후**에 **교체 알고리즘이 작동**하는 것을 가정하였다. 
이 방법은 그리 효율적이지 않기 때문에 ==**운영체제는 항상 어느 정도의 여유 메모리 공간을 확보하**==고 있어야 한다. 

메모리에 항상 어느 정도의 여유 공간을 비워두기 위해서, 대부분의 운영체제는 여유 공간에 관련된 **최댓값(high watermark**, HW)과 **최솟값(low watermark**, LW)을 설정하여 교체 알고리즘 작동에 활용한다. 
1. 운영체제가 여유 공간의 크기가 **최솟값보다 작아지면** 
2. 여유 공간 확보를 담당하는 백그라운드 쓰레드가 실행되어 
3. 여유 공간의 크기가 **최댓값에 이를 때까지** 페이지를 제거한다. 
이 백그라운드 쓰레드는 일반적으로 **스왑 데몬(swap daemon)** 또는 **페이지 데몬 (page daemon)** 이라고 불린다. 
많은 시스템들은 다수의 페이지들을 **클러스터(cluster)** 나 **그룹(group)으로 묶어서** 한 번에 스왑 파티션에 저장함으로써 디스크의 효율을 높이는 방법을 사용하기도 한다. 

## 24. 6 요약
이 장에서는 시스템에 실제 존재하는 물리 메모리의 크기보다 더 많은 메모리를 사용하기 위한 **Swap Space**에 관련된 개념을 소개했다. 
- 메모리에 특정 페이지가 존재하는지를 알리기 위해 PTE에 적혀 있는 **present bit**
- 메모리에 특정 페이지가 없을 때 발생하는 **page fault**
- **page fault**를 처리하기 위해 OS가 실행시키는 **page-fault handler**
- **page-fault handler**는 메모리의 일부 페이지들을 먼저 교체하여 **page-replacement policy**에 의해 새롭게 스왑되서 들어올 페이지를 위한 공간을 만든다. 
이 모든 작업들은 ==프로세스가 인지하지 못하는 상황에서 처리==되어야 한다!! 프로세스가 보기에는 ==자신은 자신의 개별적인 연속된 가상 메모리를 접근하는 것처럼== 보인다! 

다음 시간에는 내보낼 페이지를 결정하는 **page-replacement policy**에 대해 알아보자!

